This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
__init__.py
__init__.pyi
_dtype_ctypes.py
_dtype_ctypes.pyi
_dtype.py
_dtype.pyi
_internal.py
_multiarray_umath.py
_utils.py
arrayprint.py
defchararray.py
einsumfunc.py
fromnumeric.py
function_base.py
getlimits.py
multiarray.py
numeric.py
numerictypes.py
overrides.py
overrides.pyi
README_ENHANCED.md
README.md
records.py
shape_base.py
umath.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="__init__.py">
"""
The `numpy.core` submodule exists solely for backward compatibility
purposes. The original `core` was renamed to `_core` and made private.
`numpy.core` will be removed in the future.
"""
from numpy import _core

from ._utils import _raise_warning


# We used to use `np.core._ufunc_reconstruct` to unpickle.
# This is unnecessary, but old pickles saved before 1.20 will be using it,
# and there is no reason to break loading them.
def _ufunc_reconstruct(module, name):
    # The `fromlist` kwarg is required to ensure that `mod` points to the
    # inner-most module rather than the parent package when module name is
    # nested. This makes it possible to pickle non-toplevel ufuncs such as
    # scipy.special.expit for instance.
    mod = __import__(module, fromlist=[name])
    return getattr(mod, name)


# force lazy-loading of submodules to ensure a warning is printed

__all__ = ["arrayprint", "defchararray", "_dtype_ctypes", "_dtype",  # noqa: F822
           "einsumfunc", "fromnumeric", "function_base", "getlimits",
           "_internal", "multiarray", "_multiarray_umath", "numeric",
           "numerictypes", "overrides", "records", "shape_base", "umath"]

def __getattr__(attr_name):
    attr = getattr(_core, attr_name)
    _raise_warning(attr_name)
    return attr
</file>

<file path="_dtype_ctypes.py">
def __getattr__(attr_name):
    from numpy._core import _dtype_ctypes

    from ._utils import _raise_warning
    ret = getattr(_dtype_ctypes, attr_name, None)
    if ret is None:
        raise AttributeError(
            f"module 'numpy.core._dtype_ctypes' has no attribute {attr_name}")
    _raise_warning(attr_name, "_dtype_ctypes")
    return ret
</file>

<file path="_dtype.py">
def __getattr__(attr_name):
    from numpy._core import _dtype

    from ._utils import _raise_warning
    ret = getattr(_dtype, attr_name, None)
    if ret is None:
        raise AttributeError(
            f"module 'numpy.core._dtype' has no attribute {attr_name}")
    _raise_warning(attr_name, "_dtype")
    return ret
</file>

<file path="_internal.py">
from numpy._core import _internal


# Build a new array from the information in a pickle.
# Note that the name numpy.core._internal._reconstruct is embedded in
# pickles of ndarrays made with NumPy before release 1.0
# so don't remove the name here, or you'll
# break backward compatibility.
def _reconstruct(subtype, shape, dtype):
    from numpy import ndarray
    return ndarray.__new__(subtype, shape, dtype)


# Pybind11 (in versions <= 2.11.1) imports _dtype_from_pep3118 from the
# _internal submodule, therefore it must be importable without a warning.
_dtype_from_pep3118 = _internal._dtype_from_pep3118

def __getattr__(attr_name):
    from numpy._core import _internal

    from ._utils import _raise_warning
    ret = getattr(_internal, attr_name, None)
    if ret is None:
        raise AttributeError(
            f"module 'numpy.core._internal' has no attribute {attr_name}")
    _raise_warning(attr_name, "_internal")
    return ret
</file>

<file path="_multiarray_umath.py">
from numpy import ufunc
from numpy._core import _multiarray_umath

for item in _multiarray_umath.__dir__():
    # ufuncs appear in pickles with a path in numpy.core._multiarray_umath
    # and so must import from this namespace without warning or error
    attr = getattr(_multiarray_umath, item)
    if isinstance(attr, ufunc):
        globals()[item] = attr


def __getattr__(attr_name):
    from numpy._core import _multiarray_umath

    from ._utils import _raise_warning

    if attr_name in {"_ARRAY_API", "_UFUNC_API"}:
        import sys
        import textwrap
        import traceback

        from numpy.version import short_version

        msg = textwrap.dedent(f"""
            A module that was compiled using NumPy 1.x cannot be run in
            NumPy {short_version} as it may crash. To support both 1.x and 2.x
            versions of NumPy, modules must be compiled with NumPy 2.0.
            Some module may need to rebuild instead e.g. with 'pybind11>=2.12'.

            If you are a user of the module, the easiest solution will be to
            downgrade to 'numpy<2' or try to upgrade the affected module.
            We expect that some modules will need time to support NumPy 2.

            """)
        tb_msg = "Traceback (most recent call last):"
        for line in traceback.format_stack()[:-1]:
            if "frozen importlib" in line:
                continue
            tb_msg += line

        # Also print the message (with traceback).  This is because old versions
        # of NumPy unfortunately set up the import to replace (and hide) the
        # error.  The traceback shouldn't be needed, but e.g. pytest plugins
        # seem to swallow it and we should be failing anyway...
        sys.stderr.write(msg + tb_msg)
        raise ImportError(msg)

    ret = getattr(_multiarray_umath, attr_name, None)
    if ret is None:
        raise AttributeError(
            "module 'numpy.core._multiarray_umath' has no attribute "
            f"{attr_name}")
    _raise_warning(attr_name, "_multiarray_umath")
    return ret


del _multiarray_umath, ufunc
</file>

<file path="_utils.py">
import warnings


def _raise_warning(attr: str, submodule: str | None = None) -> None:
    new_module = "numpy._core"
    old_module = "numpy.core"
    if submodule is not None:
        new_module = f"{new_module}.{submodule}"
        old_module = f"{old_module}.{submodule}"
    warnings.warn(
        f"{old_module} is deprecated and has been renamed to {new_module}. "
        "The numpy._core namespace contains private NumPy internals and its "
        "use is discouraged, as NumPy internals can change without warning in "
        "any release. In practice, most real-world usage of numpy.core is to "
        "access functionality in the public NumPy API. If that is the case, "
        "use the public NumPy API. If not, you are using NumPy internals. "
        "If you would still like to access an internal attribute, "
        f"use {new_module}.{attr}.",
        DeprecationWarning,
        stacklevel=3
    )
</file>

<file path="arrayprint.py">
def __getattr__(attr_name):
    from numpy._core import arrayprint

    from ._utils import _raise_warning
    ret = getattr(arrayprint, attr_name, None)
    if ret is None:
        raise AttributeError(
            f"module 'numpy.core.arrayprint' has no attribute {attr_name}")
    _raise_warning(attr_name, "arrayprint")
    return ret
</file>

<file path="defchararray.py">
def __getattr__(attr_name):
    from numpy._core import defchararray

    from ._utils import _raise_warning
    ret = getattr(defchararray, attr_name, None)
    if ret is None:
        raise AttributeError(
            f"module 'numpy.core.defchararray' has no attribute {attr_name}")
    _raise_warning(attr_name, "defchararray")
    return ret
</file>

<file path="einsumfunc.py">
def __getattr__(attr_name):
    from numpy._core import einsumfunc

    from ._utils import _raise_warning
    ret = getattr(einsumfunc, attr_name, None)
    if ret is None:
        raise AttributeError(
            f"module 'numpy.core.einsumfunc' has no attribute {attr_name}")
    _raise_warning(attr_name, "einsumfunc")
    return ret
</file>

<file path="fromnumeric.py">
def __getattr__(attr_name):
    from numpy._core import fromnumeric

    from ._utils import _raise_warning
    ret = getattr(fromnumeric, attr_name, None)
    if ret is None:
        raise AttributeError(
            f"module 'numpy.core.fromnumeric' has no attribute {attr_name}")
    _raise_warning(attr_name, "fromnumeric")
    return ret
</file>

<file path="function_base.py">
def __getattr__(attr_name):
    from numpy._core import function_base

    from ._utils import _raise_warning
    ret = getattr(function_base, attr_name, None)
    if ret is None:
        raise AttributeError(
            f"module 'numpy.core.function_base' has no attribute {attr_name}")
    _raise_warning(attr_name, "function_base")
    return ret
</file>

<file path="getlimits.py">
def __getattr__(attr_name):
    from numpy._core import getlimits

    from ._utils import _raise_warning
    ret = getattr(getlimits, attr_name, None)
    if ret is None:
        raise AttributeError(
            f"module 'numpy.core.getlimits' has no attribute {attr_name}")
    _raise_warning(attr_name, "getlimits")
    return ret
</file>

<file path="multiarray.py">
from numpy._core import multiarray

# these must import without warning or error from numpy.core.multiarray to
# support old pickle files
for item in ["_reconstruct", "scalar"]:
    globals()[item] = getattr(multiarray, item)

# Pybind11 (in versions <= 2.11.1) imports _ARRAY_API from the multiarray
# submodule as a part of NumPy initialization, therefore it must be importable
# without a warning.
_ARRAY_API = multiarray._ARRAY_API

def __getattr__(attr_name):
    from numpy._core import multiarray

    from ._utils import _raise_warning
    ret = getattr(multiarray, attr_name, None)
    if ret is None:
        raise AttributeError(
            f"module 'numpy.core.multiarray' has no attribute {attr_name}")
    _raise_warning(attr_name, "multiarray")
    return ret


del multiarray
</file>

<file path="numeric.py">
def __getattr__(attr_name):
    from numpy._core import numeric

    from ._utils import _raise_warning

    sentinel = object()
    ret = getattr(numeric, attr_name, sentinel)
    if ret is sentinel:
        raise AttributeError(
            f"module 'numpy.core.numeric' has no attribute {attr_name}")
    _raise_warning(attr_name, "numeric")
    return ret
</file>

<file path="numerictypes.py">
def __getattr__(attr_name):
    from numpy._core import numerictypes

    from ._utils import _raise_warning
    ret = getattr(numerictypes, attr_name, None)
    if ret is None:
        raise AttributeError(
            f"module 'numpy.core.numerictypes' has no attribute {attr_name}")
    _raise_warning(attr_name, "numerictypes")
    return ret
</file>

<file path="overrides.py">
def __getattr__(attr_name):
    from numpy._core import overrides

    from ._utils import _raise_warning
    ret = getattr(overrides, attr_name, None)
    if ret is None:
        raise AttributeError(
            f"module 'numpy.core.overrides' has no attribute {attr_name}")
    _raise_warning(attr_name, "overrides")
    return ret
</file>

<file path="overrides.pyi">
# NOTE: At runtime, this submodule dynamically re-exports any `numpy._core.overrides`
# member, and issues a `DeprecationWarning` when accessed. But since there is no
# `__dir__` or `__all__` present, these annotations would be unverifiable. Because
# this module is also deprecated in favor of `numpy._core`, and therefore not part of
# the public API, we omit the "re-exports", which in practice would require literal
# duplication of the stubs in order for the `@deprecated` decorator to be understood
# by type-checkers.
</file>

<file path="README_ENHANCED.md">
# core

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "core",
  "description": "Directory containing 19 code files with 0 classes and 21 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Python"
    }
  ],
  "featureList": [
    "21 function definitions"
  ]
}
</script>

## Overview

This directory contains 19 code file(s) with extracted schemas.

## Files and Schemas

### `__init__.py` (python)

**Functions:**
- `_ufunc_reconstruct(module, name)` - Line 14
- `__getattr__(attr_name)` - Line 30

**Key Imports:** `_utils`, `numpy`

### `_dtype.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `_dtype_ctypes.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `_internal.py` (python)

**Functions:**
- `_reconstruct(subtype, shape, dtype)` - Line 9
- `__getattr__(attr_name)` - Line 18

**Key Imports:** `_utils`, `numpy`, `numpy._core`

### `_multiarray_umath.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 12

**Key Imports:** `_utils`, `numpy`, `numpy._core`, `numpy.version`, `sys` (+2 more)

### `_utils.py` (python)

**Functions:**
- `_raise_warning(attr, submodule) -> <ast.Constant object at 0x10630a590>` - Line 4

**Key Imports:** `warnings`

### `arrayprint.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `defchararray.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `einsumfunc.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `fromnumeric.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `function_base.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `getlimits.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `multiarray.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 13

**Key Imports:** `_utils`, `numpy._core`

### `numeric.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `numerictypes.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `overrides.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `records.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `shape_base.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `umath.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="README.md">
# core

## Overview

This directory contains 19 code file(s) with extracted schemas.

## Files and Schemas

### `__init__.py` (python)

**Functions:**
- `_ufunc_reconstruct(module, name)` - Line 14
- `__getattr__(attr_name)` - Line 30

**Key Imports:** `_utils`, `numpy`

### `_dtype.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `_dtype_ctypes.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `_internal.py` (python)

**Functions:**
- `_reconstruct(subtype, shape, dtype)` - Line 9
- `__getattr__(attr_name)` - Line 18

**Key Imports:** `_utils`, `numpy`, `numpy._core`

### `_multiarray_umath.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 12

**Key Imports:** `_utils`, `numpy`, `numpy._core`, `numpy.version`, `sys` (+2 more)

### `_utils.py` (python)

**Functions:**
- `_raise_warning(attr, submodule) -> <ast.Constant object at 0x102b11050>` - Line 4

**Key Imports:** `warnings`

### `arrayprint.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `defchararray.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `einsumfunc.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `fromnumeric.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `function_base.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `getlimits.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `multiarray.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 13

**Key Imports:** `_utils`, `numpy._core`

### `numeric.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `numerictypes.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `overrides.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `records.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `shape_base.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

### `umath.py` (python)

**Functions:**
- `__getattr__(attr_name)` - Line 1

**Key Imports:** `_utils`, `numpy._core`

---
*Generated by Schema Generator*
</file>

<file path="records.py">
def __getattr__(attr_name):
    from numpy._core import records

    from ._utils import _raise_warning
    ret = getattr(records, attr_name, None)
    if ret is None:
        raise AttributeError(
            f"module 'numpy.core.records' has no attribute {attr_name}")
    _raise_warning(attr_name, "records")
    return ret
</file>

<file path="shape_base.py">
def __getattr__(attr_name):
    from numpy._core import shape_base

    from ._utils import _raise_warning
    ret = getattr(shape_base, attr_name, None)
    if ret is None:
        raise AttributeError(
            f"module 'numpy.core.shape_base' has no attribute {attr_name}")
    _raise_warning(attr_name, "shape_base")
    return ret
</file>

<file path="umath.py">
def __getattr__(attr_name):
    from numpy._core import umath

    from ._utils import _raise_warning
    ret = getattr(umath, attr_name, None)
    if ret is None:
        raise AttributeError(
            f"module 'numpy.core.umath' has no attribute {attr_name}")
    _raise_warning(attr_name, "umath")
    return ret
</file>

</files>
