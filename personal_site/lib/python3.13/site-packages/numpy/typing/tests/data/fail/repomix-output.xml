This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
arithmetic.pyi
array_constructors.pyi
array_like.pyi
array_pad.pyi
arrayprint.pyi
arrayterator.pyi
bitwise_ops.pyi
char.pyi
chararray.pyi
comparisons.pyi
constants.pyi
datasource.pyi
dtype.pyi
einsumfunc.pyi
flatiter.pyi
fromnumeric.pyi
histograms.pyi
index_tricks.pyi
lib_function_base.pyi
lib_polynomial.pyi
lib_utils.pyi
lib_version.pyi
linalg.pyi
ma.pyi
memmap.pyi
modules.pyi
multiarray.pyi
ndarray_misc.pyi
ndarray.pyi
nditer.pyi
nested_sequence.pyi
npyio.pyi
numerictypes.pyi
random.pyi
rec.pyi
scalars.pyi
shape_base.pyi
shape.pyi
stride_tricks.pyi
strings.pyi
testing.pyi
twodim_base.pyi
type_check.pyi
ufunc_config.pyi
ufunclike.pyi
ufuncs.pyi
warnings_and_errors.pyi
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="arithmetic.pyi">
from typing import Any

import numpy as np
import numpy.typing as npt

b_ = np.bool()
dt = np.datetime64(0, "D")
td = np.timedelta64(0, "D")

AR_b: npt.NDArray[np.bool]
AR_u: npt.NDArray[np.uint32]
AR_i: npt.NDArray[np.int64]
AR_f: npt.NDArray[np.longdouble]
AR_c: npt.NDArray[np.complex128]
AR_m: npt.NDArray[np.timedelta64]
AR_M: npt.NDArray[np.datetime64]

ANY: Any

AR_LIKE_b: list[bool]
AR_LIKE_u: list[np.uint32]
AR_LIKE_i: list[int]
AR_LIKE_f: list[float]
AR_LIKE_c: list[complex]
AR_LIKE_m: list[np.timedelta64]
AR_LIKE_M: list[np.datetime64]

# Array subtraction

# NOTE: mypys `NoReturn` errors are, unfortunately, not that great
_1 = AR_b - AR_LIKE_b  # type: ignore[var-annotated]
_2 = AR_LIKE_b - AR_b  # type: ignore[var-annotated]
AR_i - bytes()  # type: ignore[operator]

AR_f - AR_LIKE_m  # type: ignore[operator]
AR_f - AR_LIKE_M  # type: ignore[operator]
AR_c - AR_LIKE_m  # type: ignore[operator]
AR_c - AR_LIKE_M  # type: ignore[operator]

AR_m - AR_LIKE_f  # type: ignore[operator]
AR_M - AR_LIKE_f  # type: ignore[operator]
AR_m - AR_LIKE_c  # type: ignore[operator]
AR_M - AR_LIKE_c  # type: ignore[operator]

AR_m - AR_LIKE_M  # type: ignore[operator]
AR_LIKE_m - AR_M  # type: ignore[operator]

# array floor division

AR_M // AR_LIKE_b  # type: ignore[operator]
AR_M // AR_LIKE_u  # type: ignore[operator]
AR_M // AR_LIKE_i  # type: ignore[operator]
AR_M // AR_LIKE_f  # type: ignore[operator]
AR_M // AR_LIKE_c  # type: ignore[operator]
AR_M // AR_LIKE_m  # type: ignore[operator]
AR_M // AR_LIKE_M  # type: ignore[operator]

AR_b // AR_LIKE_M  # type: ignore[operator]
AR_u // AR_LIKE_M  # type: ignore[operator]
AR_i // AR_LIKE_M  # type: ignore[operator]
AR_f // AR_LIKE_M  # type: ignore[operator]
AR_c // AR_LIKE_M  # type: ignore[operator]
AR_m // AR_LIKE_M  # type: ignore[operator]
AR_M // AR_LIKE_M  # type: ignore[operator]

_3 = AR_m // AR_LIKE_b  # type: ignore[var-annotated]
AR_m // AR_LIKE_c  # type: ignore[operator]

AR_b // AR_LIKE_m  # type: ignore[operator]
AR_u // AR_LIKE_m  # type: ignore[operator]
AR_i // AR_LIKE_m  # type: ignore[operator]
AR_f // AR_LIKE_m  # type: ignore[operator]
AR_c // AR_LIKE_m  # type: ignore[operator]

# regression tests for https://github.com/numpy/numpy/issues/28957
AR_c // 2  # type: ignore[operator]
AR_c // AR_i  # type: ignore[operator]
AR_c // AR_c  # type: ignore[operator]

# Array multiplication

AR_b *= AR_LIKE_u  # type: ignore[arg-type]
AR_b *= AR_LIKE_i  # type: ignore[arg-type]
AR_b *= AR_LIKE_f  # type: ignore[arg-type]
AR_b *= AR_LIKE_c  # type: ignore[arg-type]
AR_b *= AR_LIKE_m  # type: ignore[arg-type]

AR_u *= AR_LIKE_f  # type: ignore[arg-type]
AR_u *= AR_LIKE_c  # type: ignore[arg-type]
AR_u *= AR_LIKE_m  # type: ignore[arg-type]

AR_i *= AR_LIKE_f  # type: ignore[arg-type]
AR_i *= AR_LIKE_c  # type: ignore[arg-type]
AR_i *= AR_LIKE_m  # type: ignore[arg-type]

AR_f *= AR_LIKE_c  # type: ignore[arg-type]
AR_f *= AR_LIKE_m  # type: ignore[arg-type]

# Array power

AR_b **= AR_LIKE_b  # type: ignore[misc]
AR_b **= AR_LIKE_u  # type: ignore[misc]
AR_b **= AR_LIKE_i  # type: ignore[misc]
AR_b **= AR_LIKE_f  # type: ignore[misc]
AR_b **= AR_LIKE_c  # type: ignore[misc]

AR_u **= AR_LIKE_f  # type: ignore[arg-type]
AR_u **= AR_LIKE_c  # type: ignore[arg-type]

AR_i **= AR_LIKE_f  # type: ignore[arg-type]
AR_i **= AR_LIKE_c  # type: ignore[arg-type]

AR_f **= AR_LIKE_c  # type: ignore[arg-type]

# Scalars

b_ - b_  # type: ignore[call-overload]

dt + dt  # type: ignore[operator]
td - dt  # type: ignore[operator]
td % 1  # type: ignore[operator]
td / dt  # type: ignore[operator]
td % dt  # type: ignore[operator]

-b_  # type: ignore[operator]
+b_  # type: ignore[operator]
</file>

<file path="array_constructors.pyi">
import numpy as np
import numpy.typing as npt

a: npt.NDArray[np.float64]
generator = (i for i in range(10))

np.require(a, requirements=1)  # type: ignore[call-overload]
np.require(a, requirements="TEST")  # type: ignore[arg-type]

np.zeros("test")  # type: ignore[arg-type]
np.zeros()  # type: ignore[call-overload]

np.ones("test")  # type: ignore[arg-type]
np.ones()  # type: ignore[call-overload]

np.array(0, float, True)  # type: ignore[call-overload]

np.linspace(None, 'bob')  # type: ignore[call-overload]
np.linspace(0, 2, num=10.0)  # type: ignore[call-overload]
np.linspace(0, 2, endpoint='True')  # type: ignore[call-overload]
np.linspace(0, 2, retstep=b'False')  # type: ignore[call-overload]
np.linspace(0, 2, dtype=0)  # type: ignore[call-overload]
np.linspace(0, 2, axis=None)  # type: ignore[call-overload]

np.logspace(None, 'bob')  # type: ignore[call-overload]
np.logspace(0, 2, base=None)  # type: ignore[call-overload]

np.geomspace(None, 'bob')  # type: ignore[call-overload]

np.stack(generator)  # type: ignore[call-overload]
np.hstack({1, 2})  # type: ignore[call-overload]
np.vstack(1)  # type: ignore[call-overload]

np.array([1], like=1)  # type: ignore[call-overload]
</file>

<file path="array_like.pyi">
import numpy as np
from numpy._typing import ArrayLike

class A: ...

x1: ArrayLike = (i for i in range(10))  # type: ignore[assignment]
x2: ArrayLike = A()  # type: ignore[assignment]
x3: ArrayLike = {1: "foo", 2: "bar"}  # type: ignore[assignment]

scalar = np.int64(1)
scalar.__array__(dtype=np.float64)  # type: ignore[call-overload]
array = np.array([1])
array.__array__(dtype=np.float64)  # type: ignore[call-overload]

array.setfield(np.eye(1), np.int32, (0, 1))  # type: ignore[arg-type]
</file>

<file path="array_pad.pyi">
import numpy as np
import numpy.typing as npt

AR_i8: npt.NDArray[np.int64]

np.pad(AR_i8, 2, mode="bob")  # type: ignore[call-overload]
</file>

<file path="arrayprint.pyi">
from collections.abc import Callable
from typing import Any

import numpy as np
import numpy.typing as npt

AR: npt.NDArray[np.float64]
func1: Callable[[Any], str]
func2: Callable[[np.integer], str]

np.array2string(AR, style=None)  # type: ignore[call-overload]
np.array2string(AR, legacy="1.14")  # type: ignore[call-overload]
np.array2string(AR, sign="*")  # type: ignore[call-overload]
np.array2string(AR, floatmode="default")  # type: ignore[call-overload]
np.array2string(AR, formatter={"A": func1})  # type: ignore[call-overload]
np.array2string(AR, formatter={"float": func2})  # type: ignore[call-overload]
</file>

<file path="arrayterator.pyi">
import numpy as np
import numpy.typing as npt

AR_i8: npt.NDArray[np.int64]
ar_iter = np.lib.Arrayterator(AR_i8)

np.lib.Arrayterator(np.int64())  # type: ignore[arg-type]
ar_iter.shape = (10, 5)  # type: ignore[misc]
ar_iter[None]  # type: ignore[index]
ar_iter[None, 1]  # type: ignore[index]
ar_iter[np.intp()]  # type: ignore[index]
ar_iter[np.intp(), ...]  # type: ignore[index]
ar_iter[AR_i8]  # type: ignore[index]
ar_iter[AR_i8, :]  # type: ignore[index]
</file>

<file path="bitwise_ops.pyi">
import numpy as np

i8 = np.int64()
i4 = np.int32()
u8 = np.uint64()
b_ = np.bool()
i = int()

f8 = np.float64()

b_ >> f8  # type: ignore[call-overload]
i8 << f8  # type: ignore[call-overload]
i | f8  # type: ignore[operator]
i8 ^ f8  # type: ignore[call-overload]
u8 & f8  # type: ignore[call-overload]
~f8  # type: ignore[operator]
# TODO: Certain mixes like i4 << u8 go to float and thus should fail
</file>

<file path="char.pyi">
import numpy as np
import numpy.typing as npt

AR_U: npt.NDArray[np.str_]
AR_S: npt.NDArray[np.bytes_]

np.char.equal(AR_U, AR_S)  # type: ignore[arg-type]
np.char.not_equal(AR_U, AR_S)  # type: ignore[arg-type]

np.char.greater_equal(AR_U, AR_S)  # type: ignore[arg-type]
np.char.less_equal(AR_U, AR_S)  # type: ignore[arg-type]
np.char.greater(AR_U, AR_S)  # type: ignore[arg-type]
np.char.less(AR_U, AR_S)  # type: ignore[arg-type]

np.char.encode(AR_S)  # type: ignore[arg-type]
np.char.decode(AR_U)  # type: ignore[arg-type]

np.char.join(AR_U, b"_")  # type: ignore[arg-type]
np.char.join(AR_S, "_")  # type: ignore[arg-type]

np.char.ljust(AR_U, 5, fillchar=b"a")  # type: ignore[arg-type]
np.char.ljust(AR_S, 5, fillchar="a")  # type: ignore[arg-type]
np.char.rjust(AR_U, 5, fillchar=b"a")  # type: ignore[arg-type]
np.char.rjust(AR_S, 5, fillchar="a")  # type: ignore[arg-type]

np.char.lstrip(AR_U, chars=b"a")  # type: ignore[arg-type]
np.char.lstrip(AR_S, chars="a")  # type: ignore[arg-type]
np.char.strip(AR_U, chars=b"a")  # type: ignore[arg-type]
np.char.strip(AR_S, chars="a")  # type: ignore[arg-type]
np.char.rstrip(AR_U, chars=b"a")  # type: ignore[arg-type]
np.char.rstrip(AR_S, chars="a")  # type: ignore[arg-type]

np.char.partition(AR_U, b"a")  # type: ignore[arg-type]
np.char.partition(AR_S, "a")  # type: ignore[arg-type]
np.char.rpartition(AR_U, b"a")  # type: ignore[arg-type]
np.char.rpartition(AR_S, "a")  # type: ignore[arg-type]

np.char.replace(AR_U, b"_", b"-")  # type: ignore[arg-type]
np.char.replace(AR_S, "_", "-")  # type: ignore[arg-type]

np.char.split(AR_U, b"_")  # type: ignore[arg-type]
np.char.split(AR_S, "_")  # type: ignore[arg-type]
np.char.rsplit(AR_U, b"_")  # type: ignore[arg-type]
np.char.rsplit(AR_S, "_")  # type: ignore[arg-type]

np.char.count(AR_U, b"a", start=[1, 2, 3])  # type: ignore[arg-type]
np.char.count(AR_S, "a", end=9)  # type: ignore[arg-type]

np.char.endswith(AR_U, b"a", start=[1, 2, 3])  # type: ignore[arg-type]
np.char.endswith(AR_S, "a", end=9)  # type: ignore[arg-type]
np.char.startswith(AR_U, b"a", start=[1, 2, 3])  # type: ignore[arg-type]
np.char.startswith(AR_S, "a", end=9)  # type: ignore[arg-type]

np.char.find(AR_U, b"a", start=[1, 2, 3])  # type: ignore[arg-type]
np.char.find(AR_S, "a", end=9)  # type: ignore[arg-type]
np.char.rfind(AR_U, b"a", start=[1, 2, 3])  # type: ignore[arg-type]
np.char.rfind(AR_S, "a", end=9)  # type: ignore[arg-type]

np.char.index(AR_U, b"a", start=[1, 2, 3])  # type: ignore[arg-type]
np.char.index(AR_S, "a", end=9)  # type: ignore[arg-type]
np.char.rindex(AR_U, b"a", start=[1, 2, 3])  # type: ignore[arg-type]
np.char.rindex(AR_S, "a", end=9)  # type: ignore[arg-type]

np.char.isdecimal(AR_S)  # type: ignore[arg-type]
np.char.isnumeric(AR_S)  # type: ignore[arg-type]
</file>

<file path="chararray.pyi">
from typing import Any
import numpy as np

AR_U: np.char.chararray[tuple[Any, ...], np.dtype[np.str_]]
AR_S: np.char.chararray[tuple[Any, ...], np.dtype[np.bytes_]]

AR_S.encode()  # type: ignore[misc]
AR_U.decode()  # type: ignore[misc]

AR_U.join(b"_")  # type: ignore[arg-type]
AR_S.join("_")  # type: ignore[arg-type]

AR_U.ljust(5, fillchar=b"a")  # type: ignore[arg-type]
AR_S.ljust(5, fillchar="a")  # type: ignore[arg-type]
AR_U.rjust(5, fillchar=b"a")  # type: ignore[arg-type]
AR_S.rjust(5, fillchar="a")  # type: ignore[arg-type]

AR_U.lstrip(chars=b"a")  # type: ignore[arg-type]
AR_S.lstrip(chars="a")  # type: ignore[arg-type]
AR_U.strip(chars=b"a")  # type: ignore[arg-type]
AR_S.strip(chars="a")  # type: ignore[arg-type]
AR_U.rstrip(chars=b"a")  # type: ignore[arg-type]
AR_S.rstrip(chars="a")  # type: ignore[arg-type]

AR_U.partition(b"a")  # type: ignore[arg-type]
AR_S.partition("a")  # type: ignore[arg-type]
AR_U.rpartition(b"a")  # type: ignore[arg-type]
AR_S.rpartition("a")  # type: ignore[arg-type]

AR_U.replace(b"_", b"-")  # type: ignore[arg-type]
AR_S.replace("_", "-")  # type: ignore[arg-type]

AR_U.split(b"_")  # type: ignore[arg-type]
AR_S.split("_")  # type: ignore[arg-type]
AR_S.split(1)  # type: ignore[arg-type]
AR_U.rsplit(b"_")  # type: ignore[arg-type]
AR_S.rsplit("_")  # type: ignore[arg-type]

AR_U.count(b"a", start=[1, 2, 3])  # type: ignore[arg-type]
AR_S.count("a", end=9)  # type: ignore[arg-type]

AR_U.endswith(b"a", start=[1, 2, 3])  # type: ignore[arg-type]
AR_S.endswith("a", end=9)  # type: ignore[arg-type]
AR_U.startswith(b"a", start=[1, 2, 3])  # type: ignore[arg-type]
AR_S.startswith("a", end=9)  # type: ignore[arg-type]

AR_U.find(b"a", start=[1, 2, 3])  # type: ignore[arg-type]
AR_S.find("a", end=9)  # type: ignore[arg-type]
AR_U.rfind(b"a", start=[1, 2, 3])  # type: ignore[arg-type]
AR_S.rfind("a", end=9)  # type: ignore[arg-type]

AR_U.index(b"a", start=[1, 2, 3])  # type: ignore[arg-type]
AR_S.index("a", end=9)  # type: ignore[arg-type]
AR_U.rindex(b"a", start=[1, 2, 3])  # type: ignore[arg-type]
AR_S.rindex("a", end=9)  # type: ignore[arg-type]

AR_U == AR_S  # type: ignore[operator]
AR_U != AR_S  # type: ignore[operator]
AR_U >= AR_S  # type: ignore[operator]
AR_U <= AR_S  # type: ignore[operator]
AR_U > AR_S  # type: ignore[operator]
AR_U < AR_S  # type: ignore[operator]
</file>

<file path="comparisons.pyi">
import numpy as np
import numpy.typing as npt

AR_i: npt.NDArray[np.int64]
AR_f: npt.NDArray[np.float64]
AR_c: npt.NDArray[np.complex128]
AR_m: npt.NDArray[np.timedelta64]
AR_M: npt.NDArray[np.datetime64]

AR_f > AR_m  # type: ignore[operator]
AR_c > AR_m  # type: ignore[operator]

AR_m > AR_f  # type: ignore[operator]
AR_m > AR_c  # type: ignore[operator]

AR_i > AR_M  # type: ignore[operator]
AR_f > AR_M  # type: ignore[operator]
AR_m > AR_M  # type: ignore[operator]

AR_M > AR_i  # type: ignore[operator]
AR_M > AR_f  # type: ignore[operator]
AR_M > AR_m  # type: ignore[operator]

AR_i > str()  # type: ignore[operator]
AR_i > bytes()  # type: ignore[operator]
str() > AR_M  # type: ignore[operator]
bytes() > AR_M  # type: ignore[operator]
</file>

<file path="constants.pyi">
import numpy as np

np.little_endian = np.little_endian  # type: ignore[misc]
</file>

<file path="datasource.pyi">
from pathlib import Path
import numpy as np

path: Path
d1: np.lib.npyio.DataSource

d1.abspath(path)  # type: ignore[arg-type]
d1.abspath(b"...")  # type: ignore[arg-type]

d1.exists(path)  # type: ignore[arg-type]
d1.exists(b"...")  # type: ignore[arg-type]

d1.open(path, "r")  # type: ignore[arg-type]
d1.open(b"...", encoding="utf8")  # type: ignore[arg-type]
d1.open(None, newline="/n")  # type: ignore[arg-type]
</file>

<file path="dtype.pyi">
import numpy as np

class Test1:
    not_dtype = np.dtype(float)

class Test2:
    dtype = float

np.dtype(Test1())  # type: ignore[call-overload]
np.dtype(Test2())  # type: ignore[arg-type]

np.dtype(  # type: ignore[call-overload]
    {
        "field1": (float, 1),
        "field2": (int, 3),
    }
)
</file>

<file path="einsumfunc.pyi">
import numpy as np
import numpy.typing as npt

AR_i: npt.NDArray[np.int64]
AR_f: npt.NDArray[np.float64]
AR_m: npt.NDArray[np.timedelta64]
AR_U: npt.NDArray[np.str_]

np.einsum("i,i->i", AR_i, AR_m)  # type: ignore[arg-type]
np.einsum("i,i->i", AR_f, AR_f, dtype=np.int32)  # type: ignore[arg-type]
np.einsum("i,i->i", AR_i, AR_i, out=AR_U)  # type: ignore[type-var]
np.einsum("i,i->i", AR_i, AR_i, out=AR_U, casting="unsafe")  # type: ignore[call-overload]
</file>

<file path="flatiter.pyi">
import numpy as np
import numpy._typing as npt

class Index:
    def __index__(self) -> int: ...

a: np.flatiter[npt.NDArray[np.float64]]
supports_array: npt._SupportsArray[np.dtype[np.float64]]

a.base = object()  # type: ignore[assignment, misc]
a.coords = object()  # type: ignore[assignment, misc]
a.index = object()  # type: ignore[assignment, misc]
a.copy(order='C')  # type: ignore[call-arg]

# NOTE: Contrary to `ndarray.__getitem__` its counterpart in `flatiter`
# does not accept objects with the `__array__` or `__index__` protocols;
# boolean indexing is just plain broken (gh-17175)
a[np.bool()]  # type: ignore[index]
a[Index()]  # type: ignore[call-overload]
a[supports_array]  # type: ignore[index]
</file>

<file path="fromnumeric.pyi">
"""Tests for :mod:`numpy._core.fromnumeric`."""

import numpy as np
import numpy.typing as npt

A = np.array(True, ndmin=2, dtype=bool)
A.setflags(write=False)
AR_U: npt.NDArray[np.str_]
AR_M: npt.NDArray[np.datetime64]
AR_f4: npt.NDArray[np.float32]

a = np.bool(True)

np.take(a, None)  # type: ignore[call-overload]
np.take(a, axis=1.0)  # type: ignore[call-overload]
np.take(A, out=1)  # type: ignore[call-overload]
np.take(A, mode="bob")  # type: ignore[call-overload]

np.reshape(a, None)  # type: ignore[call-overload]
np.reshape(A, 1, order="bob")  # type: ignore[call-overload]

np.choose(a, None)  # type: ignore[call-overload]
np.choose(a, out=1.0)  # type: ignore[call-overload]
np.choose(A, mode="bob")  # type: ignore[call-overload]

np.repeat(a, None)  # type: ignore[call-overload]
np.repeat(A, 1, axis=1.0)  # type: ignore[call-overload]

np.swapaxes(A, None, 1)  # type: ignore[call-overload]
np.swapaxes(A, 1, [0])  # type: ignore[call-overload]

np.transpose(A, axes=1.0)  # type: ignore[call-overload]

np.partition(a, None)  # type: ignore[call-overload]
np.partition(a, 0, axis="bob") # type: ignore[call-overload]
np.partition(A, 0, kind="bob")  # type: ignore[call-overload]
np.partition(A, 0, order=range(5))  # type: ignore[arg-type]

np.argpartition(a, None)  # type: ignore[arg-type]
np.argpartition(a, 0, axis="bob")  # type: ignore[arg-type]
np.argpartition(A, 0, kind="bob") # type: ignore[arg-type]
np.argpartition(A, 0, order=range(5))  # type: ignore[arg-type]

np.sort(A, axis="bob")  # type: ignore[call-overload]
np.sort(A, kind="bob")  # type: ignore[call-overload]
np.sort(A, order=range(5)) # type: ignore[arg-type]

np.argsort(A, axis="bob")  # type: ignore[arg-type]
np.argsort(A, kind="bob")  # type: ignore[arg-type]
np.argsort(A, order=range(5))  # type: ignore[arg-type]

np.argmax(A, axis="bob")  # type: ignore[call-overload]
np.argmax(A, kind="bob")  # type: ignore[call-overload]
np.argmax(A, out=AR_f4)  # type: ignore[type-var]

np.argmin(A, axis="bob")  # type: ignore[call-overload]
np.argmin(A, kind="bob")  # type: ignore[call-overload]
np.argmin(A, out=AR_f4)  # type: ignore[type-var]

np.searchsorted(A[0], 0, side="bob")  # type: ignore[call-overload]
np.searchsorted(A[0], 0, sorter=1.0)  # type: ignore[call-overload]

np.resize(A, 1.0)  # type: ignore[call-overload]

np.squeeze(A, 1.0)  # type: ignore[call-overload]

np.diagonal(A, offset=None)  # type: ignore[call-overload]
np.diagonal(A, axis1="bob")  # type: ignore[call-overload]
np.diagonal(A, axis2=[])  # type: ignore[call-overload]

np.trace(A, offset=None)  # type: ignore[call-overload]
np.trace(A, axis1="bob")  # type: ignore[call-overload]
np.trace(A, axis2=[])  # type: ignore[call-overload]

np.ravel(a, order="bob")  # type: ignore[call-overload]

np.nonzero(0)  # type: ignore[arg-type]

np.compress([True], A, axis=1.0)  # type: ignore[call-overload]

np.clip(a, 1, 2, out=1)  # type: ignore[call-overload]

np.sum(a, axis=1.0)  # type: ignore[call-overload]
np.sum(a, keepdims=1.0)  # type: ignore[call-overload]
np.sum(a, initial=[1])  # type: ignore[call-overload]

np.all(a, axis=1.0)  # type: ignore[call-overload]
np.all(a, keepdims=1.0)  # type: ignore[call-overload]
np.all(a, out=1.0)  # type: ignore[call-overload]

np.any(a, axis=1.0)  # type: ignore[call-overload]
np.any(a, keepdims=1.0)  # type: ignore[call-overload]
np.any(a, out=1.0)  # type: ignore[call-overload]

np.cumsum(a, axis=1.0)  # type: ignore[call-overload]
np.cumsum(a, dtype=1.0)  # type: ignore[call-overload]
np.cumsum(a, out=1.0)  # type: ignore[call-overload]

np.ptp(a, axis=1.0)  # type: ignore[call-overload]
np.ptp(a, keepdims=1.0)  # type: ignore[call-overload]
np.ptp(a, out=1.0)  # type: ignore[call-overload]

np.amax(a, axis=1.0)  # type: ignore[call-overload]
np.amax(a, keepdims=1.0)  # type: ignore[call-overload]
np.amax(a, out=1.0)  # type: ignore[call-overload]
np.amax(a, initial=[1.0])  # type: ignore[call-overload]
np.amax(a, where=[1.0])  # type: ignore[arg-type]

np.amin(a, axis=1.0)  # type: ignore[call-overload]
np.amin(a, keepdims=1.0)  # type: ignore[call-overload]
np.amin(a, out=1.0)  # type: ignore[call-overload]
np.amin(a, initial=[1.0])  # type: ignore[call-overload]
np.amin(a, where=[1.0])  # type: ignore[arg-type]

np.prod(a, axis=1.0)  # type: ignore[call-overload]
np.prod(a, out=False)  # type: ignore[call-overload]
np.prod(a, keepdims=1.0)  # type: ignore[call-overload]
np.prod(a, initial=int)  # type: ignore[call-overload]
np.prod(a, where=1.0)  # type: ignore[call-overload]
np.prod(AR_U)  # type: ignore[arg-type]

np.cumprod(a, axis=1.0)  # type: ignore[call-overload]
np.cumprod(a, out=False)  # type: ignore[call-overload]
np.cumprod(AR_U)  # type: ignore[arg-type]

np.size(a, axis=1.0)  # type: ignore[arg-type]

np.around(a, decimals=1.0)  # type: ignore[call-overload]
np.around(a, out=type)  # type: ignore[call-overload]
np.around(AR_U)  # type: ignore[arg-type]

np.mean(a, axis=1.0)  # type: ignore[call-overload]
np.mean(a, out=False)  # type: ignore[call-overload]
np.mean(a, keepdims=1.0)  # type: ignore[call-overload]
np.mean(AR_U)  # type: ignore[arg-type]
np.mean(AR_M)  # type: ignore[arg-type]

np.std(a, axis=1.0)  # type: ignore[call-overload]
np.std(a, out=False)  # type: ignore[call-overload]
np.std(a, ddof='test')  # type: ignore[call-overload]
np.std(a, keepdims=1.0)  # type: ignore[call-overload]
np.std(AR_U)  # type: ignore[arg-type]

np.var(a, axis=1.0)  # type: ignore[call-overload]
np.var(a, out=False)  # type: ignore[call-overload]
np.var(a, ddof='test')  # type: ignore[call-overload]
np.var(a, keepdims=1.0)  # type: ignore[call-overload]
np.var(AR_U)  # type: ignore[arg-type]
</file>

<file path="histograms.pyi">
import numpy as np
import numpy.typing as npt

AR_i8: npt.NDArray[np.int64]
AR_f8: npt.NDArray[np.float64]

np.histogram_bin_edges(AR_i8, range=(0, 1, 2))  # type: ignore[arg-type]

np.histogram(AR_i8, range=(0, 1, 2))  # type: ignore[arg-type]

np.histogramdd(AR_i8, range=(0, 1))  # type: ignore[arg-type]
np.histogramdd(AR_i8, range=[(0, 1, 2)])  # type: ignore[list-item]
</file>

<file path="index_tricks.pyi">
import numpy as np

AR_LIKE_i: list[int]
AR_LIKE_f: list[float]

np.ndindex([1, 2, 3])  # type: ignore[call-overload]
np.unravel_index(AR_LIKE_f, (1, 2, 3))  # type: ignore[arg-type]
np.ravel_multi_index(AR_LIKE_i, (1, 2, 3), mode="bob")  # type: ignore[call-overload]
np.mgrid[1]  # type: ignore[index]
np.mgrid[...]  # type: ignore[index]
np.ogrid[1]  # type: ignore[index]
np.ogrid[...]  # type: ignore[index]
np.fill_diagonal(AR_LIKE_f, 2)  # type: ignore[arg-type]
np.diag_indices(1.0)  # type: ignore[arg-type]
</file>

<file path="lib_function_base.pyi">
from typing import Any

import numpy as np
import numpy.typing as npt

AR_f8: npt.NDArray[np.float64]
AR_c16: npt.NDArray[np.complex128]
AR_m: npt.NDArray[np.timedelta64]
AR_M: npt.NDArray[np.datetime64]
AR_O: npt.NDArray[np.object_]
AR_b_list: list[npt.NDArray[np.bool]]

def fn_none_i(a: None, /) -> npt.NDArray[Any]: ...
def fn_ar_i(a: npt.NDArray[np.float64], posarg: int, /) -> npt.NDArray[Any]: ...

np.average(AR_m)  # type: ignore[arg-type]
np.select(1, [AR_f8])  # type: ignore[arg-type]
np.angle(AR_m)  # type: ignore[arg-type]
np.unwrap(AR_m)  # type: ignore[arg-type]
np.unwrap(AR_c16)  # type: ignore[arg-type]
np.trim_zeros(1)  # type: ignore[arg-type]
np.place(1, [True], 1.5)  # type: ignore[arg-type]
np.vectorize(1)  # type: ignore[arg-type]
np.place(AR_f8, slice(None), 5)  # type: ignore[arg-type]

np.piecewise(AR_f8, True, [fn_ar_i], 42)  # type: ignore[call-overload]
# TODO: enable these once mypy actually supports ParamSpec (released in 2021)
# NOTE: pyright correctly reports errors for these (`reportCallIssue`)
# np.piecewise(AR_f8, AR_b_list, [fn_none_i])  # type: ignore[call-overload]s
# np.piecewise(AR_f8, AR_b_list, [fn_ar_i])  # type: ignore[call-overload]
# np.piecewise(AR_f8, AR_b_list, [fn_ar_i], 3.14)  # type: ignore[call-overload]
# np.piecewise(AR_f8, AR_b_list, [fn_ar_i], 42, None)  # type: ignore[call-overload]
# np.piecewise(AR_f8, AR_b_list, [fn_ar_i], 42, _=None)  # type: ignore[call-overload]

np.interp(AR_f8, AR_c16, AR_f8)  # type: ignore[arg-type]
np.interp(AR_c16, AR_f8, AR_f8)  # type: ignore[arg-type]
np.interp(AR_f8, AR_f8, AR_f8, period=AR_c16)  # type: ignore[call-overload]
np.interp(AR_f8, AR_f8, AR_O)  # type: ignore[arg-type]

np.cov(AR_m)  # type: ignore[arg-type]
np.cov(AR_O)  # type: ignore[arg-type]
np.corrcoef(AR_m)  # type: ignore[arg-type]
np.corrcoef(AR_O)  # type: ignore[arg-type]
np.corrcoef(AR_f8, bias=True)  # type: ignore[call-overload]
np.corrcoef(AR_f8, ddof=2)  # type: ignore[call-overload]
np.blackman(1j)  # type: ignore[arg-type]
np.bartlett(1j)  # type: ignore[arg-type]
np.hanning(1j)  # type: ignore[arg-type]
np.hamming(1j)  # type: ignore[arg-type]
np.hamming(AR_c16)  # type: ignore[arg-type]
np.kaiser(1j, 1)  # type: ignore[arg-type]
np.sinc(AR_O)  # type: ignore[arg-type]
np.median(AR_M)  # type: ignore[arg-type]

np.percentile(AR_f8, 50j)  # type: ignore[call-overload]
np.percentile(AR_f8, 50, interpolation="bob")  # type: ignore[call-overload]
np.quantile(AR_f8, 0.5j)  # type: ignore[call-overload]
np.quantile(AR_f8, 0.5, interpolation="bob")  # type: ignore[call-overload]
np.meshgrid(AR_f8, AR_f8, indexing="bob")  # type: ignore[call-overload]
np.delete(AR_f8, AR_f8)  # type: ignore[arg-type]
np.insert(AR_f8, AR_f8, 1.5)  # type: ignore[arg-type]
np.digitize(AR_f8, 1j)  # type: ignore[call-overload]
</file>

<file path="lib_polynomial.pyi">
import numpy as np
import numpy.typing as npt

AR_f8: npt.NDArray[np.float64]
AR_c16: npt.NDArray[np.complex128]
AR_O: npt.NDArray[np.object_]
AR_U: npt.NDArray[np.str_]

poly_obj: np.poly1d

np.polymul(AR_f8, AR_U)  # type: ignore[arg-type]
np.polydiv(AR_f8, AR_U)  # type: ignore[arg-type]

5**poly_obj  # type: ignore[operator]

np.polyint(AR_U)  # type: ignore[arg-type]
np.polyint(AR_f8, m=1j)  # type: ignore[call-overload]

np.polyder(AR_U)  # type: ignore[arg-type]
np.polyder(AR_f8, m=1j)  # type: ignore[call-overload]

np.polyfit(AR_O, AR_f8, 1)  # type: ignore[arg-type]
np.polyfit(AR_f8, AR_f8, 1, rcond=1j)  # type: ignore[call-overload]
np.polyfit(AR_f8, AR_f8, 1, w=AR_c16)  # type: ignore[arg-type]
np.polyfit(AR_f8, AR_f8, 1, cov="bob")  # type: ignore[call-overload]

np.polyval(AR_f8, AR_U)  # type: ignore[arg-type]
np.polyadd(AR_f8, AR_U)  # type: ignore[arg-type]
np.polysub(AR_f8, AR_U)  # type: ignore[arg-type]
</file>

<file path="lib_utils.pyi">
import numpy.lib.array_utils as array_utils

array_utils.byte_bounds(1)  # type: ignore[arg-type]
</file>

<file path="lib_version.pyi">
from numpy.lib import NumpyVersion

version: NumpyVersion

NumpyVersion(b"1.8.0")  # type: ignore[arg-type]
version >= b"1.8.0"  # type: ignore[operator]
</file>

<file path="linalg.pyi">
import numpy as np
import numpy.typing as npt

AR_f8: npt.NDArray[np.float64]
AR_O: npt.NDArray[np.object_]
AR_M: npt.NDArray[np.datetime64]

np.linalg.tensorsolve(AR_O, AR_O)  # type: ignore[arg-type]

np.linalg.solve(AR_O, AR_O)  # type: ignore[arg-type]

np.linalg.tensorinv(AR_O)  # type: ignore[arg-type]

np.linalg.inv(AR_O)  # type: ignore[arg-type]

np.linalg.matrix_power(AR_M, 5)  # type: ignore[arg-type]

np.linalg.cholesky(AR_O)  # type: ignore[arg-type]

np.linalg.qr(AR_O)  # type: ignore[arg-type]
np.linalg.qr(AR_f8, mode="bob")  # type: ignore[call-overload]

np.linalg.eigvals(AR_O)  # type: ignore[arg-type]

np.linalg.eigvalsh(AR_O)  # type: ignore[arg-type]
np.linalg.eigvalsh(AR_O, UPLO="bob")  # type: ignore[call-overload]

np.linalg.eig(AR_O)  # type: ignore[arg-type]

np.linalg.eigh(AR_O)  # type: ignore[arg-type]
np.linalg.eigh(AR_O, UPLO="bob")  # type: ignore[call-overload]

np.linalg.svd(AR_O)  # type: ignore[arg-type]

np.linalg.cond(AR_O)  # type: ignore[arg-type]
np.linalg.cond(AR_f8, p="bob")  # type: ignore[arg-type]

np.linalg.matrix_rank(AR_O)  # type: ignore[arg-type]

np.linalg.pinv(AR_O)  # type: ignore[arg-type]

np.linalg.slogdet(AR_O)  # type: ignore[arg-type]

np.linalg.det(AR_O)  # type: ignore[arg-type]

np.linalg.norm(AR_f8, ord="bob")  # type: ignore[call-overload]

np.linalg.multi_dot([AR_M])  # type: ignore[list-item]
</file>

<file path="ma.pyi">
from typing import TypeAlias, TypeVar

import numpy as np
import numpy.typing as npt
from numpy._typing import _Shape

_ScalarT = TypeVar("_ScalarT", bound=np.generic)
MaskedArray: TypeAlias = np.ma.MaskedArray[_Shape, np.dtype[_ScalarT]]

MAR_1d_f8: np.ma.MaskedArray[tuple[int], np.dtype[np.float64]]
MAR_b: MaskedArray[np.bool]
MAR_c: MaskedArray[np.complex128]
MAR_td64: MaskedArray[np.timedelta64]

AR_b: npt.NDArray[np.bool]

MAR_1d_f8.shape = (3, 1)  # type: ignore[assignment]
MAR_1d_f8.dtype = np.bool  # type: ignore[assignment]

np.ma.min(MAR_1d_f8, axis=1.0)  # type: ignore[call-overload]
np.ma.min(MAR_1d_f8, keepdims=1.0)  # type: ignore[call-overload]
np.ma.min(MAR_1d_f8, out=1.0)  # type: ignore[call-overload]
np.ma.min(MAR_1d_f8, fill_value=lambda x: 27)  # type: ignore[call-overload]

MAR_1d_f8.min(axis=1.0)  # type: ignore[call-overload]
MAR_1d_f8.min(keepdims=1.0)  # type: ignore[call-overload]
MAR_1d_f8.min(out=1.0)  # type: ignore[call-overload]
MAR_1d_f8.min(fill_value=lambda x: 27)  # type: ignore[call-overload]

np.ma.max(MAR_1d_f8, axis=1.0)  # type: ignore[call-overload]
np.ma.max(MAR_1d_f8, keepdims=1.0)  # type: ignore[call-overload]
np.ma.max(MAR_1d_f8, out=1.0)  # type: ignore[call-overload]
np.ma.max(MAR_1d_f8, fill_value=lambda x: 27)  # type: ignore[call-overload]

MAR_1d_f8.max(axis=1.0)  # type: ignore[call-overload]
MAR_1d_f8.max(keepdims=1.0)  # type: ignore[call-overload]
MAR_1d_f8.max(out=1.0)  # type: ignore[call-overload]
MAR_1d_f8.max(fill_value=lambda x: 27)  # type: ignore[call-overload]

np.ma.ptp(MAR_1d_f8, axis=1.0)  # type: ignore[call-overload]
np.ma.ptp(MAR_1d_f8, keepdims=1.0)  # type: ignore[call-overload]
np.ma.ptp(MAR_1d_f8, out=1.0)  # type: ignore[call-overload]
np.ma.ptp(MAR_1d_f8, fill_value=lambda x: 27)  # type: ignore[call-overload]

MAR_1d_f8.ptp(axis=1.0)  # type: ignore[call-overload]
MAR_1d_f8.ptp(keepdims=1.0)  # type: ignore[call-overload]
MAR_1d_f8.ptp(out=1.0)  # type: ignore[call-overload]
MAR_1d_f8.ptp(fill_value=lambda x: 27)  # type: ignore[call-overload]

MAR_1d_f8.argmin(axis=1.0)  # type: ignore[call-overload]
MAR_1d_f8.argmin(keepdims=1.0)  # type: ignore[call-overload]
MAR_1d_f8.argmin(out=1.0)  # type: ignore[call-overload]
MAR_1d_f8.argmin(fill_value=lambda x: 27)  # type: ignore[call-overload]

np.ma.argmin(MAR_1d_f8, axis=1.0)  # type: ignore[call-overload]
np.ma.argmin(MAR_1d_f8, axis=(1,))  # type: ignore[call-overload]
np.ma.argmin(MAR_1d_f8, keepdims=1.0)  # type: ignore[call-overload]
np.ma.argmin(MAR_1d_f8, out=1.0)  # type: ignore[call-overload]
np.ma.argmin(MAR_1d_f8, fill_value=lambda x: 27)  # type: ignore[call-overload]

MAR_1d_f8.argmax(axis=1.0)  # type: ignore[call-overload]
MAR_1d_f8.argmax(keepdims=1.0)  # type: ignore[call-overload]
MAR_1d_f8.argmax(out=1.0)  # type: ignore[call-overload]
MAR_1d_f8.argmax(fill_value=lambda x: 27)  # type: ignore[call-overload]

np.ma.argmax(MAR_1d_f8, axis=1.0)  # type: ignore[call-overload]
np.ma.argmax(MAR_1d_f8, axis=(0,))  # type: ignore[call-overload]
np.ma.argmax(MAR_1d_f8, keepdims=1.0)  # type: ignore[call-overload]
np.ma.argmax(MAR_1d_f8, out=1.0)  # type: ignore[call-overload]
np.ma.argmax(MAR_1d_f8, fill_value=lambda x: 27)  # type: ignore[call-overload]

MAR_1d_f8.all(axis=1.0)  # type: ignore[call-overload]
MAR_1d_f8.all(keepdims=1.0)  # type: ignore[call-overload]
MAR_1d_f8.all(out=1.0)  # type: ignore[call-overload]

MAR_1d_f8.any(axis=1.0)  # type: ignore[call-overload]
MAR_1d_f8.any(keepdims=1.0)  # type: ignore[call-overload]
MAR_1d_f8.any(out=1.0)  # type: ignore[call-overload]

MAR_1d_f8.sort(axis=(0,1))  # type: ignore[arg-type]
MAR_1d_f8.sort(axis=None)  # type: ignore[arg-type]
MAR_1d_f8.sort(kind='cabbage')  # type: ignore[arg-type]
MAR_1d_f8.sort(order=lambda: 'cabbage')  # type: ignore[arg-type]
MAR_1d_f8.sort(endwith='cabbage')  # type: ignore[arg-type]
MAR_1d_f8.sort(fill_value=lambda: 'cabbage')  # type: ignore[arg-type]
MAR_1d_f8.sort(stable='cabbage')  # type: ignore[arg-type]
MAR_1d_f8.sort(stable=True)  # type: ignore[arg-type]

MAR_1d_f8.take(axis=1.0)  # type: ignore[call-overload]
MAR_1d_f8.take(out=1)  # type: ignore[call-overload]
MAR_1d_f8.take(mode="bob")  # type: ignore[call-overload]

np.ma.take(None)  # type: ignore[call-overload]
np.ma.take(axis=1.0)  # type: ignore[call-overload]
np.ma.take(out=1)  # type: ignore[call-overload]
np.ma.take(mode="bob")  # type: ignore[call-overload]

MAR_1d_f8.partition(['cabbage'])  # type: ignore[arg-type]
MAR_1d_f8.partition(axis=(0,1))  # type: ignore[arg-type, call-arg]
MAR_1d_f8.partition(kind='cabbage')  # type: ignore[arg-type, call-arg]
MAR_1d_f8.partition(order=lambda: 'cabbage')  # type: ignore[arg-type, call-arg]
MAR_1d_f8.partition(AR_b)  # type: ignore[arg-type]

MAR_1d_f8.argpartition(['cabbage'])  # type: ignore[arg-type]
MAR_1d_f8.argpartition(axis=(0,1))  # type: ignore[arg-type, call-arg]
MAR_1d_f8.argpartition(kind='cabbage')  # type: ignore[arg-type, call-arg]
MAR_1d_f8.argpartition(order=lambda: 'cabbage')  # type: ignore[arg-type, call-arg]
MAR_1d_f8.argpartition(AR_b)  # type: ignore[arg-type]

np.ma.ndim(lambda: 'lambda')  # type: ignore[arg-type]

np.ma.size(AR_b, axis='0')  # type: ignore[arg-type]

MAR_1d_f8 >= (lambda x: 'mango') # type: ignore[operator]
MAR_1d_f8 > (lambda x: 'mango') # type: ignore[operator]
MAR_1d_f8 <= (lambda x: 'mango') # type: ignore[operator]
MAR_1d_f8 < (lambda x: 'mango') # type: ignore[operator]

MAR_1d_f8.count(axis=0.)  # type: ignore[call-overload]

np.ma.count(MAR_1d_f8, axis=0.)  # type: ignore[call-overload]

MAR_1d_f8.put(4, 999, mode='flip')  # type: ignore[arg-type]

np.ma.put(MAR_1d_f8, 4, 999, mode='flip')  # type: ignore[arg-type]

np.ma.put([1,1,3], 0, 999)  # type: ignore[arg-type]

np.ma.compressed(lambda: 'compress me')  # type: ignore[call-overload]

np.ma.allequal(MAR_1d_f8, [1,2,3], fill_value=1.5)  # type: ignore[arg-type]

np.ma.allclose(MAR_1d_f8, [1,2,3], masked_equal=4.5)  # type: ignore[arg-type]
np.ma.allclose(MAR_1d_f8, [1,2,3], rtol='.4')  # type: ignore[arg-type]
np.ma.allclose(MAR_1d_f8, [1,2,3], atol='.5')  # type: ignore[arg-type]

MAR_1d_f8.__setmask__('mask')  # type: ignore[arg-type]

MAR_b *= 2  # type: ignore[arg-type]
MAR_c //= 2  # type: ignore[misc]
MAR_td64 **= 2  # type: ignore[misc]

MAR_1d_f8.swapaxes(axis1=1, axis2=0)  # type: ignore[call-arg]
</file>

<file path="memmap.pyi">
import numpy as np

with open("file.txt", "r") as f:
    np.memmap(f)  # type: ignore[call-overload]
np.memmap("test.txt", shape=[10, 5])  # type: ignore[call-overload]
</file>

<file path="modules.pyi">
import numpy as np

np.testing.bob  # type: ignore[attr-defined]
np.bob  # type: ignore[attr-defined]

# Stdlib modules in the namespace by accident
np.warnings  # type: ignore[attr-defined]
np.sys  # type: ignore[attr-defined]
np.os  # type: ignore[attr-defined]
np.math  # type: ignore[attr-defined]

# Public sub-modules that are not imported to their parent module by default;
# e.g. one must first execute `import numpy.lib.recfunctions`
np.lib.recfunctions  # type: ignore[attr-defined]

np.__deprecated_attrs__  # type: ignore[attr-defined]
np.__expired_functions__  # type: ignore[attr-defined]
</file>

<file path="multiarray.pyi">
import numpy as np
import numpy.typing as npt

i8: np.int64

AR_b: npt.NDArray[np.bool]
AR_u1: npt.NDArray[np.uint8]
AR_i8: npt.NDArray[np.int64]
AR_f8: npt.NDArray[np.float64]
AR_M: npt.NDArray[np.datetime64]

M: np.datetime64

AR_LIKE_f: list[float]

def func(a: int) -> None: ...

np.where(AR_b, 1)  # type: ignore[call-overload]

np.can_cast(AR_f8, 1)  # type: ignore[arg-type]

np.vdot(AR_M, AR_M)  # type: ignore[arg-type]

np.copyto(AR_LIKE_f, AR_f8)  # type: ignore[arg-type]

np.putmask(AR_LIKE_f, [True, True, False], 1.5)  # type: ignore[arg-type]

np.packbits(AR_f8)  # type: ignore[arg-type]
np.packbits(AR_u1, bitorder=">")  # type: ignore[arg-type]

np.unpackbits(AR_i8)  # type: ignore[arg-type]
np.unpackbits(AR_u1, bitorder=">")  # type: ignore[arg-type]

np.shares_memory(1, 1, max_work=i8)  # type: ignore[arg-type]
np.may_share_memory(1, 1, max_work=i8)  # type: ignore[arg-type]

np.arange(stop=10)  # type: ignore[call-overload]

np.datetime_data(int)  # type: ignore[arg-type]

np.busday_offset("2012", 10)  # type: ignore[call-overload]

np.datetime_as_string("2012")  # type: ignore[call-overload]

np.char.compare_chararrays("a", b"a", "==", False)  # type: ignore[call-overload]

np.nested_iters([AR_i8, AR_i8])  # type: ignore[call-arg]
np.nested_iters([AR_i8, AR_i8], 0)  # type: ignore[arg-type]
np.nested_iters([AR_i8, AR_i8], [0])  # type: ignore[list-item]
np.nested_iters([AR_i8, AR_i8], [[0], [1]], flags=["test"])  # type: ignore[list-item]
np.nested_iters([AR_i8, AR_i8], [[0], [1]], op_flags=[["test"]])  # type: ignore[list-item]
np.nested_iters([AR_i8, AR_i8], [[0], [1]], buffersize=1.0)  # type: ignore[arg-type]
</file>

<file path="ndarray_misc.pyi">
"""
Tests for miscellaneous (non-magic) ``np.ndarray``/``np.generic`` methods.

More extensive tests are performed for the methods'
function-based counterpart in `../from_numeric.py`.

"""

import numpy as np
import numpy.typing as npt

f8: np.float64
AR_f8: npt.NDArray[np.float64]
AR_M: npt.NDArray[np.datetime64]
AR_b: npt.NDArray[np.bool]

ctypes_obj = AR_f8.ctypes

f8.argpartition(0)  # type: ignore[attr-defined]
f8.diagonal()  # type: ignore[attr-defined]
f8.dot(1)  # type: ignore[attr-defined]
f8.nonzero()  # type: ignore[attr-defined]
f8.partition(0)  # type: ignore[attr-defined]
f8.put(0, 2)  # type: ignore[attr-defined]
f8.setfield(2, np.float64)  # type: ignore[attr-defined]
f8.sort()  # type: ignore[attr-defined]
f8.trace()  # type: ignore[attr-defined]

AR_M.__complex__()  # type: ignore[misc]
AR_b.__index__()  # type: ignore[misc]

AR_f8[1.5]  # type: ignore[call-overload]
AR_f8["field_a"]  # type: ignore[call-overload]
AR_f8[["field_a", "field_b"]]  # type: ignore[index]

AR_f8.__array_finalize__(object())  # type: ignore[arg-type]
</file>

<file path="ndarray.pyi">
import numpy as np

# Ban setting dtype since mutating the type of the array in place
# makes having ndarray be generic over dtype impossible. Generally
# users should use `ndarray.view` in this situation anyway. See
#
# https://github.com/numpy/numpy-stubs/issues/7
#
# for more context.
float_array = np.array([1.0])
float_array.dtype = np.bool  # type: ignore[assignment, misc]
</file>

<file path="nditer.pyi">
import numpy as np

class Test(np.nditer): ...  # type: ignore[misc]

np.nditer([0, 1], flags=["test"])  # type: ignore[list-item]
np.nditer([0, 1], op_flags=[["test"]])  # type: ignore[list-item]
np.nditer([0, 1], itershape=(1.0,))  # type: ignore[arg-type]
np.nditer([0, 1], buffersize=1.0)  # type: ignore[arg-type]
</file>

<file path="nested_sequence.pyi">
from collections.abc import Sequence
from numpy._typing import _NestedSequence

a: Sequence[float]
b: list[complex]
c: tuple[str, ...]
d: int
e: str

def func(a: _NestedSequence[int]) -> None: ...

reveal_type(func(a))  # type: ignore[arg-type, misc]
reveal_type(func(b))  # type: ignore[arg-type, misc]
reveal_type(func(c))  # type: ignore[arg-type, misc]
reveal_type(func(d))  # type: ignore[arg-type, misc]
reveal_type(func(e))  # type: ignore[arg-type, misc]
</file>

<file path="npyio.pyi">
import pathlib
from typing import IO

import numpy.typing as npt
import numpy as np

str_path: str
bytes_path: bytes
pathlib_path: pathlib.Path
str_file: IO[str]
AR_i8: npt.NDArray[np.int64]

np.load(str_file)  # type: ignore[arg-type]

np.save(bytes_path, AR_i8)  # type: ignore[call-overload]
np.save(str_path, AR_i8, fix_imports=True)  # type: ignore[deprecated]  # pyright: ignore[reportDeprecated]

np.savez(bytes_path, AR_i8)  # type: ignore[arg-type]

np.savez_compressed(bytes_path, AR_i8)  # type: ignore[arg-type]

np.loadtxt(bytes_path)  # type: ignore[arg-type]

np.fromregex(bytes_path, ".", np.int64)  # type: ignore[call-overload]
</file>

<file path="numerictypes.pyi">
import numpy as np

np.isdtype(1, np.int64)  # type: ignore[arg-type]

np.issubdtype(1, np.int64)  # type: ignore[arg-type]
</file>

<file path="random.pyi">
import numpy as np
import numpy.typing as npt

SEED_FLOAT: float = 457.3
SEED_ARR_FLOAT: npt.NDArray[np.float64] = np.array([1.0, 2, 3, 4])
SEED_ARRLIKE_FLOAT: list[float] = [1.0, 2.0, 3.0, 4.0]
SEED_SEED_SEQ: np.random.SeedSequence = np.random.SeedSequence(0)
SEED_STR: str = "String seeding not allowed"

# default rng
np.random.default_rng(SEED_FLOAT)  # type: ignore[arg-type]
np.random.default_rng(SEED_ARR_FLOAT)  # type: ignore[arg-type]
np.random.default_rng(SEED_ARRLIKE_FLOAT)  # type: ignore[arg-type]
np.random.default_rng(SEED_STR)  # type: ignore[arg-type]

# Seed Sequence
np.random.SeedSequence(SEED_FLOAT)  # type: ignore[arg-type]
np.random.SeedSequence(SEED_ARR_FLOAT)  # type: ignore[arg-type]
np.random.SeedSequence(SEED_ARRLIKE_FLOAT)  # type: ignore[arg-type]
np.random.SeedSequence(SEED_SEED_SEQ)  # type: ignore[arg-type]
np.random.SeedSequence(SEED_STR)  # type: ignore[arg-type]

seed_seq: np.random.bit_generator.SeedSequence = np.random.SeedSequence()
seed_seq.spawn(11.5)  # type: ignore[arg-type]
seed_seq.generate_state(3.14)  # type: ignore[arg-type]
seed_seq.generate_state(3, np.uint8)  # type: ignore[arg-type]
seed_seq.generate_state(3, "uint8")  # type: ignore[arg-type]
seed_seq.generate_state(3, "u1")  # type: ignore[arg-type]
seed_seq.generate_state(3, np.uint16)  # type: ignore[arg-type]
seed_seq.generate_state(3, "uint16")  # type: ignore[arg-type]
seed_seq.generate_state(3, "u2")  # type: ignore[arg-type]
seed_seq.generate_state(3, np.int32)  # type: ignore[arg-type]
seed_seq.generate_state(3, "int32")  # type: ignore[arg-type]
seed_seq.generate_state(3, "i4")  # type: ignore[arg-type]

# Bit Generators
np.random.MT19937(SEED_FLOAT)  # type: ignore[arg-type]
np.random.MT19937(SEED_ARR_FLOAT)  # type: ignore[arg-type]
np.random.MT19937(SEED_ARRLIKE_FLOAT)  # type: ignore[arg-type]
np.random.MT19937(SEED_STR)  # type: ignore[arg-type]

np.random.PCG64(SEED_FLOAT)  # type: ignore[arg-type]
np.random.PCG64(SEED_ARR_FLOAT)  # type: ignore[arg-type]
np.random.PCG64(SEED_ARRLIKE_FLOAT)  # type: ignore[arg-type]
np.random.PCG64(SEED_STR)  # type: ignore[arg-type]

np.random.Philox(SEED_FLOAT)  # type: ignore[arg-type]
np.random.Philox(SEED_ARR_FLOAT)  # type: ignore[arg-type]
np.random.Philox(SEED_ARRLIKE_FLOAT)  # type: ignore[arg-type]
np.random.Philox(SEED_STR)  # type: ignore[arg-type]

np.random.SFC64(SEED_FLOAT)  # type: ignore[arg-type]
np.random.SFC64(SEED_ARR_FLOAT)  # type: ignore[arg-type]
np.random.SFC64(SEED_ARRLIKE_FLOAT)  # type: ignore[arg-type]
np.random.SFC64(SEED_STR)  # type: ignore[arg-type]

# Generator
np.random.Generator(None)  # type: ignore[arg-type]
np.random.Generator(12333283902830213)  # type: ignore[arg-type]
np.random.Generator("OxFEEDF00D")  # type: ignore[arg-type]
np.random.Generator([123, 234])  # type: ignore[arg-type]
np.random.Generator(np.array([123, 234], dtype="u4"))  # type: ignore[arg-type]
</file>

<file path="rec.pyi">
import numpy as np
import numpy.typing as npt

AR_i8: npt.NDArray[np.int64]

np.rec.fromarrays(1)  # type: ignore[call-overload]
np.rec.fromarrays([1, 2, 3], dtype=[("f8", "f8")], formats=["f8", "f8"])  # type: ignore[call-overload]

np.rec.fromrecords(AR_i8)  # type: ignore[arg-type]
np.rec.fromrecords([(1.5,)], dtype=[("f8", "f8")], formats=["f8", "f8"])  # type: ignore[call-overload]

np.rec.fromstring("string", dtype=[("f8", "f8")])  # type: ignore[call-overload]
np.rec.fromstring(b"bytes")  # type: ignore[call-overload]
np.rec.fromstring(b"(1.5,)", dtype=[("f8", "f8")], formats=["f8", "f8"])  # type: ignore[call-overload]

with open("test", "r") as f:
    np.rec.fromfile(f, dtype=[("f8", "f8")])  # type: ignore[call-overload]
</file>

<file path="scalars.pyi">
import sys
import numpy as np

f2: np.float16
f8: np.float64
c8: np.complex64

# Construction

np.float32(3j)  # type: ignore[arg-type]

# Technically the following examples are valid NumPy code. But they
# are not considered a best practice, and people who wish to use the
# stubs should instead do
#
# np.array([1.0, 0.0, 0.0], dtype=np.float32)
# np.array([], dtype=np.complex64)
#
# See e.g. the discussion on the mailing list
#
# https://mail.python.org/pipermail/numpy-discussion/2020-April/080566.html
#
# and the issue
#
# https://github.com/numpy/numpy-stubs/issues/41
#
# for more context.
np.float32([1.0, 0.0, 0.0])  # type: ignore[arg-type]
np.complex64([])  # type: ignore[call-overload]

# TODO: protocols (can't check for non-existent protocols w/ __getattr__)

np.datetime64(0)  # type: ignore[call-overload]

class A:
    def __float__(self) -> float: ...

np.int8(A())  # type: ignore[arg-type]
np.int16(A())  # type: ignore[arg-type]
np.int32(A())  # type: ignore[arg-type]
np.int64(A())  # type: ignore[arg-type]
np.uint8(A())  # type: ignore[arg-type]
np.uint16(A())  # type: ignore[arg-type]
np.uint32(A())  # type: ignore[arg-type]
np.uint64(A())  # type: ignore[arg-type]

np.void("test")  # type: ignore[call-overload]
np.void("test", dtype=None)  # type: ignore[call-overload]

np.generic(1)  # type: ignore[abstract]
np.number(1)  # type: ignore[abstract]
np.integer(1)  # type: ignore[abstract]
np.inexact(1)  # type: ignore[abstract]
np.character("test")  # type: ignore[abstract]
np.flexible(b"test")  # type: ignore[abstract]

np.float64(value=0.0)  # type: ignore[call-arg]
np.int64(value=0)  # type: ignore[call-arg]
np.uint64(value=0)  # type: ignore[call-arg]
np.complex128(value=0.0j)  # type: ignore[call-overload]
np.str_(value='bob')  # type: ignore[call-overload]
np.bytes_(value=b'test')  # type: ignore[call-overload]
np.void(value=b'test')  # type: ignore[call-overload]
np.bool(value=True)  # type: ignore[call-overload]
np.datetime64(value="2019")  # type: ignore[call-overload]
np.timedelta64(value=0)  # type: ignore[call-overload]

np.bytes_(b"hello", encoding='utf-8')  # type: ignore[call-overload]
np.str_("hello", encoding='utf-8')  # type: ignore[call-overload]

f8.item(1)  # type: ignore[call-overload]
f8.item((0, 1))  # type: ignore[arg-type]
f8.squeeze(axis=1)  # type: ignore[arg-type]
f8.squeeze(axis=(0, 1))  # type: ignore[arg-type]
f8.transpose(1)  # type: ignore[arg-type]

def func(a: np.float32) -> None: ...

func(f2)  # type: ignore[arg-type]
func(f8)  # type: ignore[arg-type]

c8.__getnewargs__()  # type: ignore[attr-defined]
f2.__getnewargs__()  # type: ignore[attr-defined]
f2.hex()  # type: ignore[attr-defined]
np.float16.fromhex("0x0.0p+0")  # type: ignore[attr-defined]
f2.__trunc__()  # type: ignore[attr-defined]
f2.__getformat__("float")  # type: ignore[attr-defined]
</file>

<file path="shape_base.pyi">
import numpy as np

class DTypeLike:
    dtype: np.dtype[np.int_]

dtype_like: DTypeLike

np.expand_dims(dtype_like, (5, 10))  # type: ignore[call-overload]
</file>

<file path="shape.pyi">
from typing import Any
import numpy as np

# test bounds of _ShapeT_co

np.ndarray[tuple[str, str], Any]  # type: ignore[type-var]
</file>

<file path="stride_tricks.pyi">
import numpy as np
import numpy.typing as npt

AR_f8: npt.NDArray[np.float64]

np.lib.stride_tricks.as_strided(AR_f8, shape=8)  # type: ignore[call-overload]
np.lib.stride_tricks.as_strided(AR_f8, strides=8)  # type: ignore[call-overload]

np.lib.stride_tricks.sliding_window_view(AR_f8, axis=(1,))  # type: ignore[call-overload]
</file>

<file path="strings.pyi">
import numpy as np
import numpy.typing as npt

AR_U: npt.NDArray[np.str_]
AR_S: npt.NDArray[np.bytes_]

np.strings.equal(AR_U, AR_S)  # type: ignore[arg-type]
np.strings.not_equal(AR_U, AR_S)  # type: ignore[arg-type]

np.strings.greater_equal(AR_U, AR_S)  # type: ignore[arg-type]
np.strings.less_equal(AR_U, AR_S)  # type: ignore[arg-type]
np.strings.greater(AR_U, AR_S)  # type: ignore[arg-type]
np.strings.less(AR_U, AR_S)  # type: ignore[arg-type]

np.strings.encode(AR_S)  # type: ignore[arg-type]
np.strings.decode(AR_U)  # type: ignore[arg-type]

np.strings.lstrip(AR_U, b"a")  # type: ignore[arg-type]
np.strings.lstrip(AR_S, "a")  # type: ignore[arg-type]
np.strings.strip(AR_U, b"a")  # type: ignore[arg-type]
np.strings.strip(AR_S, "a")  # type: ignore[arg-type]
np.strings.rstrip(AR_U, b"a")  # type: ignore[arg-type]
np.strings.rstrip(AR_S, "a")  # type: ignore[arg-type]

np.strings.partition(AR_U, b"a")  # type: ignore[arg-type]
np.strings.partition(AR_S, "a")  # type: ignore[arg-type]
np.strings.rpartition(AR_U, b"a")  # type: ignore[arg-type]
np.strings.rpartition(AR_S, "a")  # type: ignore[arg-type]

np.strings.count(AR_U, b"a", [1, 2, 3], [1, 2, 3])  # type: ignore[arg-type]
np.strings.count(AR_S, "a", 0, 9)  # type: ignore[arg-type]

np.strings.endswith(AR_U, b"a", [1, 2, 3], [1, 2, 3])  # type: ignore[arg-type]
np.strings.endswith(AR_S, "a", 0, 9)  # type: ignore[arg-type]
np.strings.startswith(AR_U, b"a", [1, 2, 3], [1, 2, 3])  # type: ignore[arg-type]
np.strings.startswith(AR_S, "a", 0, 9)  # type: ignore[arg-type]

np.strings.find(AR_U, b"a", [1, 2, 3], [1, 2, 3])  # type: ignore[arg-type]
np.strings.find(AR_S, "a", 0, 9)  # type: ignore[arg-type]
np.strings.rfind(AR_U, b"a", [1, 2, 3], [1, 2, 3])  # type: ignore[arg-type]
np.strings.rfind(AR_S, "a", 0, 9)  # type: ignore[arg-type]

np.strings.index(AR_U, b"a", start=[1, 2, 3])  # type: ignore[arg-type]
np.strings.index(AR_S, "a", end=9)  # type: ignore[arg-type]
np.strings.rindex(AR_U, b"a", start=[1, 2, 3])  # type: ignore[arg-type]
np.strings.rindex(AR_S, "a", end=9)  # type: ignore[arg-type]

np.strings.isdecimal(AR_S)  # type: ignore[arg-type]
np.strings.isnumeric(AR_S)  # type: ignore[arg-type]

np.strings.replace(AR_U, b"_", b"-", 10)  # type: ignore[arg-type]
np.strings.replace(AR_S, "_", "-", 1)  # type: ignore[arg-type]
</file>

<file path="testing.pyi">
import numpy as np
import numpy.typing as npt

AR_U: npt.NDArray[np.str_]

def func(x: object) -> bool: ...

np.testing.assert_(True, msg=1)  # type: ignore[arg-type]
np.testing.build_err_msg(1, "test")  # type: ignore[arg-type]
np.testing.assert_almost_equal(AR_U, AR_U)  # type: ignore[arg-type]
np.testing.assert_approx_equal([1, 2, 3], [1, 2, 3])  # type: ignore[arg-type]
np.testing.assert_array_almost_equal(AR_U, AR_U)  # type: ignore[arg-type]
np.testing.assert_array_less(AR_U, AR_U)  # type: ignore[arg-type]
np.testing.assert_string_equal(b"a", b"a")  # type: ignore[arg-type]

np.testing.assert_raises(expected_exception=TypeError, callable=func)  # type: ignore[call-overload]
np.testing.assert_raises_regex(expected_exception=TypeError, expected_regex="T", callable=func)  # type: ignore[call-overload]

np.testing.assert_allclose(AR_U, AR_U)  # type: ignore[arg-type]
np.testing.assert_array_almost_equal_nulp(AR_U, AR_U)  # type: ignore[arg-type]
np.testing.assert_array_max_ulp(AR_U, AR_U)  # type: ignore[arg-type]

np.testing.assert_warns(RuntimeWarning, func)  # type: ignore[call-overload]
np.testing.assert_no_warnings(func=func)  # type: ignore[call-overload]
np.testing.assert_no_warnings(func)  # type: ignore[call-overload]
np.testing.assert_no_warnings(func, y=None)  # type: ignore[call-overload]

np.testing.assert_no_gc_cycles(func=func)  # type: ignore[call-overload]
</file>

<file path="twodim_base.pyi">
from typing import Any, TypeVar

import numpy as np
import numpy.typing as npt

def func1(ar: npt.NDArray[Any], a: int) -> npt.NDArray[np.str_]: ...

def func2(ar: npt.NDArray[Any], a: float) -> float: ...

AR_b: npt.NDArray[np.bool]
AR_m: npt.NDArray[np.timedelta64]

AR_LIKE_b: list[bool]

np.eye(10, M=20.0)  # type: ignore[call-overload]
np.eye(10, k=2.5, dtype=int)  # type: ignore[call-overload]

np.diag(AR_b, k=0.5)  # type: ignore[call-overload]
np.diagflat(AR_b, k=0.5)  # type: ignore[call-overload]

np.tri(10, M=20.0)  # type: ignore[call-overload]
np.tri(10, k=2.5, dtype=int)  # type: ignore[call-overload]

np.tril(AR_b, k=0.5)  # type: ignore[call-overload]
np.triu(AR_b, k=0.5)  # type: ignore[call-overload]

np.vander(AR_m)  # type: ignore[arg-type]

np.histogram2d(AR_m)  # type: ignore[call-overload]

np.mask_indices(10, func1)  # type: ignore[arg-type]
np.mask_indices(10, func2, 10.5)  # type: ignore[arg-type]
</file>

<file path="type_check.pyi">
import numpy as np
import numpy.typing as npt

DTYPE_i8: np.dtype[np.int64]

np.mintypecode(DTYPE_i8)  # type: ignore[arg-type]
np.iscomplexobj(DTYPE_i8)  # type: ignore[arg-type]
np.isrealobj(DTYPE_i8)  # type: ignore[arg-type]

np.typename(DTYPE_i8)  # type: ignore[call-overload]
np.typename("invalid")  # type: ignore[call-overload]

np.common_type(np.timedelta64())  # type: ignore[arg-type]
</file>

<file path="ufunc_config.pyi">
"""Typing tests for `numpy._core._ufunc_config`."""

import numpy as np

def func1(a: str, b: int, c: float) -> None: ...
def func2(a: str, *, b: int) -> None: ...

class Write1:
    def write1(self, a: str) -> None: ...

class Write2:
    def write(self, a: str, b: str) -> None: ...

class Write3:
    def write(self, *, a: str) -> None: ...

np.seterrcall(func1)  # type: ignore[arg-type]
np.seterrcall(func2)  # type: ignore[arg-type]
np.seterrcall(Write1())  # type: ignore[arg-type]
np.seterrcall(Write2())  # type: ignore[arg-type]
np.seterrcall(Write3())  # type: ignore[arg-type]
</file>

<file path="ufunclike.pyi">
import numpy as np
import numpy.typing as npt

AR_c: npt.NDArray[np.complex128]
AR_m: npt.NDArray[np.timedelta64]
AR_M: npt.NDArray[np.datetime64]
AR_O: npt.NDArray[np.object_]

np.fix(AR_c)  # type: ignore[arg-type]
np.fix(AR_m)  # type: ignore[arg-type]
np.fix(AR_M)  # type: ignore[arg-type]

np.isposinf(AR_c)  # type: ignore[arg-type]
np.isposinf(AR_m)  # type: ignore[arg-type]
np.isposinf(AR_M)  # type: ignore[arg-type]
np.isposinf(AR_O)  # type: ignore[arg-type]

np.isneginf(AR_c)  # type: ignore[arg-type]
np.isneginf(AR_m)  # type: ignore[arg-type]
np.isneginf(AR_M)  # type: ignore[arg-type]
np.isneginf(AR_O)  # type: ignore[arg-type]
</file>

<file path="ufuncs.pyi">
import numpy as np
import numpy.typing as npt

AR_f8: npt.NDArray[np.float64]

np.sin.nin + "foo"  # type: ignore[operator]
np.sin(1, foo="bar")  # type: ignore[call-overload]

np.abs(None)  # type: ignore[call-overload]

np.add(1, 1, 1)  # type: ignore[call-overload]
np.add(1, 1, axis=0)  # type: ignore[call-overload]

np.matmul(AR_f8, AR_f8, where=True)  # type: ignore[call-overload]

np.frexp(AR_f8, out=None)  # type: ignore[call-overload]
np.frexp(AR_f8, out=AR_f8)  # type: ignore[call-overload]
</file>

<file path="warnings_and_errors.pyi">
import numpy.exceptions as ex

ex.AxisError(1.0)  # type: ignore[call-overload]
ex.AxisError(1, ndim=2.0)  # type: ignore[call-overload]
ex.AxisError(2, msg_prefix=404)  # type: ignore[call-overload]
</file>

</files>
