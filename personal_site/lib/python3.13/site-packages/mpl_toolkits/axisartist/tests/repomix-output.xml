This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
__init__.py
conftest.py
README_ENHANCED.md
README.md
test_angle_helper.py
test_axis_artist.py
test_axislines.py
test_floating_axes.py
test_grid_finder.py
test_grid_helper_curvelinear.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="__init__.py">
from pathlib import Path


# Check that the test directories exist
if not (Path(__file__).parent / "baseline_images").exists():
    raise OSError(
        'The baseline image directory does not exist. '
        'This is most likely because the test data is not installed. '
        'You may need to install matplotlib from source to get the '
        'test data.')
</file>

<file path="conftest.py">
from matplotlib.testing.conftest import (mpl_test_settings,  # noqa
                                         pytest_configure, pytest_unconfigure)
</file>

<file path="README_ENHANCED.md">
# tests

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "tests",
  "description": "Directory containing 6 code files with 2 classes and 26 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Python"
    }
  ],
  "featureList": [
    "2 class definitions",
    "26 function definitions"
  ]
}
</script>

## Overview

This directory contains 6 code file(s) with extracted schemas.

## Files and Schemas

### `test_angle_helper.py` (python)

**Functions:**
- `dms2float(degrees, minutes, seconds)` - Line 44
- `test_select_step(args, kwargs, expected_levels, expected_factor)` - Line 52
- `test_select_step24(args, kwargs, expected_levels, expected_factor)` - Line 64
- `test_select_step360(args, kwargs, expected_levels, expected_factor)` - Line 93
- `test_formatters(Formatter, regex, direction, factor, values)` - Line 114

**Key Imports:** `mpl_toolkits.axisartist.angle_helper`, `numpy`, `pytest`, `re`

### `test_axis_artist.py` (python)

**Functions:**
- `test_ticks()` - Line 10
- `test_labelbase()` - Line 28
- `test_ticklabels()` - Line 45
- `test_axis_artist()` - Line 80

**Key Imports:** `matplotlib.pyplot`, `matplotlib.testing.decorators`, `mpl_toolkits.axisartist`, `mpl_toolkits.axisartist.axis_artist`

### `test_axislines.py` (python)

**Functions:**
- `test_SubplotZero()` - Line 11
- `test_Subplot()` - Line 32
- `test_Axes()` - Line 51
- `test_ParasiteAxesAuxTrans()` - Line 62
- `test_axisline_style()` - Line 93
- `test_axisline_style_size_color()` - Line 107
- `test_axisline_style_tight()` - Line 121
- `test_subplotzero_ylabel()` - Line 134

**Key Imports:** `matplotlib.pyplot`, `matplotlib.testing.decorators`, `matplotlib.transforms`, `mpl_toolkits.axisartist`, `mpl_toolkits.axisartist.axislines` (+1 more)

### `test_floating_axes.py` (python)

**Functions:**
- `test_subplot()` - Line 14
- `test_curvelinear3()` - Line 23
- `test_curvelinear4()` - Line 69
- `test_axis_direction()` - Line 108

**Key Imports:** `matplotlib.projections`, `matplotlib.pyplot`, `matplotlib.testing.decorators`, `matplotlib.transforms`, `mpl_toolkits.axisartist` (+4 more)

### `test_grid_finder.py` (python)

**Functions:**
- `test_find_line_box_crossings()` - Line 9
- `test_pretty_print_format()` - Line 27

**Key Imports:** `matplotlib.transforms`, `mpl_toolkits.axisartist.grid_finder`, `numpy`, `pytest`

### `test_grid_helper_curvelinear.py` (python)

**Classes:**
- `MyTransform` (extends: Transform) - Line 20
  - Methods: __init__, transform, transform_path, inverted
- `MyTransformInv` (extends: Transform) - Line 46
  - Methods: __init__, transform, inverted

**Functions:**
- `test_custom_transform()` - Line 19
- `test_polar_box()` - Line 80
- `test_axis_direction()` - Line 141

**Key Imports:** `matplotlib.path`, `matplotlib.projections`, `matplotlib.pyplot`, `matplotlib.testing.decorators`, `matplotlib.ticker` (+6 more)

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="README.md">
# tests

## Overview

This directory contains 6 code file(s) with extracted schemas.

## Files and Schemas

### `test_angle_helper.py` (python)

**Functions:**
- `dms2float(degrees, minutes, seconds)` - Line 44
- `test_select_step(args, kwargs, expected_levels, expected_factor)` - Line 52
- `test_select_step24(args, kwargs, expected_levels, expected_factor)` - Line 64
- `test_select_step360(args, kwargs, expected_levels, expected_factor)` - Line 93
- `test_formatters(Formatter, regex, direction, factor, values)` - Line 114

**Key Imports:** `mpl_toolkits.axisartist.angle_helper`, `numpy`, `pytest`, `re`

### `test_axis_artist.py` (python)

**Functions:**
- `test_ticks()` - Line 10
- `test_labelbase()` - Line 28
- `test_ticklabels()` - Line 45
- `test_axis_artist()` - Line 80

**Key Imports:** `matplotlib.pyplot`, `matplotlib.testing.decorators`, `mpl_toolkits.axisartist`, `mpl_toolkits.axisartist.axis_artist`

### `test_axislines.py` (python)

**Functions:**
- `test_SubplotZero()` - Line 11
- `test_Subplot()` - Line 32
- `test_Axes()` - Line 51
- `test_ParasiteAxesAuxTrans()` - Line 62
- `test_axisline_style()` - Line 93
- `test_axisline_style_size_color()` - Line 107
- `test_axisline_style_tight()` - Line 121
- `test_subplotzero_ylabel()` - Line 134

**Key Imports:** `matplotlib.pyplot`, `matplotlib.testing.decorators`, `matplotlib.transforms`, `mpl_toolkits.axisartist`, `mpl_toolkits.axisartist.axislines` (+1 more)

### `test_floating_axes.py` (python)

**Functions:**
- `test_subplot()` - Line 14
- `test_curvelinear3()` - Line 23
- `test_curvelinear4()` - Line 69
- `test_axis_direction()` - Line 108

**Key Imports:** `matplotlib.projections`, `matplotlib.pyplot`, `matplotlib.testing.decorators`, `matplotlib.transforms`, `mpl_toolkits.axisartist` (+4 more)

### `test_grid_finder.py` (python)

**Functions:**
- `test_find_line_box_crossings()` - Line 9
- `test_pretty_print_format()` - Line 27

**Key Imports:** `matplotlib.transforms`, `mpl_toolkits.axisartist.grid_finder`, `numpy`, `pytest`

### `test_grid_helper_curvelinear.py` (python)

**Classes:**
- `MyTransform` (extends: Transform) - Line 20
  - Methods: __init__, transform, transform_path, inverted
- `MyTransformInv` (extends: Transform) - Line 46
  - Methods: __init__, transform, inverted

**Functions:**
- `test_custom_transform()` - Line 19
- `test_polar_box()` - Line 80
- `test_axis_direction()` - Line 141

**Key Imports:** `matplotlib.path`, `matplotlib.projections`, `matplotlib.pyplot`, `matplotlib.testing.decorators`, `matplotlib.ticker` (+6 more)

---
*Generated by Schema Generator*
</file>

<file path="test_angle_helper.py">
import re

import numpy as np
import pytest

from mpl_toolkits.axisartist.angle_helper import (
    FormatterDMS, FormatterHMS, select_step, select_step24, select_step360)


_MS_RE = (
    r'''\$  # Mathtext
        (
            # The sign sometimes appears on a 0 when a fraction is shown.
            # Check later that there's only one.
            (?P<degree_sign>-)?
            (?P<degree>[0-9.]+)  # Degrees value
            {degree}  # Degree symbol (to be replaced by format.)
        )?
        (
            (?(degree)\\,)  # Separator if degrees are also visible.
            (?P<minute_sign>-)?
            (?P<minute>[0-9.]+)  # Minutes value
            {minute}  # Minute symbol (to be replaced by format.)
        )?
        (
            (?(minute)\\,)  # Separator if minutes are also visible.
            (?P<second_sign>-)?
            (?P<second>[0-9.]+)  # Seconds value
            {second}  # Second symbol (to be replaced by format.)
        )?
        \$  # Mathtext
    '''
)
DMS_RE = re.compile(_MS_RE.format(degree=re.escape(FormatterDMS.deg_mark),
                                  minute=re.escape(FormatterDMS.min_mark),
                                  second=re.escape(FormatterDMS.sec_mark)),
                    re.VERBOSE)
HMS_RE = re.compile(_MS_RE.format(degree=re.escape(FormatterHMS.deg_mark),
                                  minute=re.escape(FormatterHMS.min_mark),
                                  second=re.escape(FormatterHMS.sec_mark)),
                    re.VERBOSE)


def dms2float(degrees, minutes=0, seconds=0):
    return degrees + minutes / 60.0 + seconds / 3600.0


@pytest.mark.parametrize('args, kwargs, expected_levels, expected_factor', [
    ((-180, 180, 10), {'hour': False}, np.arange(-180, 181, 30), 1.0),
    ((-12, 12, 10), {'hour': True}, np.arange(-12, 13, 2), 1.0)
])
def test_select_step(args, kwargs, expected_levels, expected_factor):
    levels, n, factor = select_step(*args, **kwargs)

    assert n == len(levels)
    np.testing.assert_array_equal(levels, expected_levels)
    assert factor == expected_factor


@pytest.mark.parametrize('args, kwargs, expected_levels, expected_factor', [
    ((-180, 180, 10), {}, np.arange(-180, 181, 30), 1.0),
    ((-12, 12, 10), {}, np.arange(-750, 751, 150), 60.0)
])
def test_select_step24(args, kwargs, expected_levels, expected_factor):
    levels, n, factor = select_step24(*args, **kwargs)

    assert n == len(levels)
    np.testing.assert_array_equal(levels, expected_levels)
    assert factor == expected_factor


@pytest.mark.parametrize('args, kwargs, expected_levels, expected_factor', [
    ((dms2float(20, 21.2), dms2float(21, 33.3), 5), {},
     np.arange(1215, 1306, 15), 60.0),
    ((dms2float(20.5, seconds=21.2), dms2float(20.5, seconds=33.3), 5), {},
     np.arange(73820, 73835, 2), 3600.0),
    ((dms2float(20, 21.2), dms2float(20, 53.3), 5), {},
     np.arange(1220, 1256, 5), 60.0),
    ((21.2, 33.3, 5), {},
     np.arange(20, 35, 2), 1.0),
    ((dms2float(20, 21.2), dms2float(21, 33.3), 5), {},
     np.arange(1215, 1306, 15), 60.0),
    ((dms2float(20.5, seconds=21.2), dms2float(20.5, seconds=33.3), 5), {},
     np.arange(73820, 73835, 2), 3600.0),
    ((dms2float(20.5, seconds=21.2), dms2float(20.5, seconds=21.4), 5), {},
     np.arange(7382120, 7382141, 5), 360000.0),
    # test threshold factor
    ((dms2float(20.5, seconds=11.2), dms2float(20.5, seconds=53.3), 5),
     {'threshold_factor': 60}, np.arange(12301, 12310), 600.0),
    ((dms2float(20.5, seconds=11.2), dms2float(20.5, seconds=53.3), 5),
     {'threshold_factor': 1}, np.arange(20502, 20517, 2), 1000.0),
])
def test_select_step360(args, kwargs, expected_levels, expected_factor):
    levels, n, factor = select_step360(*args, **kwargs)

    assert n == len(levels)
    np.testing.assert_array_equal(levels, expected_levels)
    assert factor == expected_factor


@pytest.mark.parametrize('Formatter, regex',
                         [(FormatterDMS, DMS_RE),
                          (FormatterHMS, HMS_RE)],
                         ids=['Degree/Minute/Second', 'Hour/Minute/Second'])
@pytest.mark.parametrize('direction, factor, values', [
    ("left", 60, [0, -30, -60]),
    ("left", 600, [12301, 12302, 12303]),
    ("left", 3600, [0, -30, -60]),
    ("left", 36000, [738210, 738215, 738220]),
    ("left", 360000, [7382120, 7382125, 7382130]),
    ("left", 1., [45, 46, 47]),
    ("left", 10., [452, 453, 454]),
])
def test_formatters(Formatter, regex, direction, factor, values):
    fmt = Formatter()
    result = fmt(direction, factor, values)

    prev_degree = prev_minute = prev_second = None
    for tick, value in zip(result, values):
        m = regex.match(tick)
        assert m is not None, f'{tick!r} is not an expected tick format.'

        sign = sum(m.group(sign + '_sign') is not None
                   for sign in ('degree', 'minute', 'second'))
        assert sign <= 1, f'Only one element of tick {tick!r} may have a sign.'
        sign = 1 if sign == 0 else -1

        degree = float(m.group('degree') or prev_degree or 0)
        minute = float(m.group('minute') or prev_minute or 0)
        second = float(m.group('second') or prev_second or 0)
        if Formatter == FormatterHMS:
            # 360 degrees as plot range -> 24 hours as labelled range
            expected_value = pytest.approx((value // 15) / factor)
        else:
            expected_value = pytest.approx(value / factor)
        assert sign * dms2float(degree, minute, second) == expected_value, \
            f'{tick!r} does not match expected tick value.'

        prev_degree = degree
        prev_minute = minute
        prev_second = second
</file>

<file path="test_axis_artist.py">
import matplotlib.pyplot as plt
from matplotlib.testing.decorators import image_comparison

from mpl_toolkits.axisartist import AxisArtistHelperRectlinear
from mpl_toolkits.axisartist.axis_artist import (AxisArtist, AxisLabel,
                                                 LabelBase, Ticks, TickLabels)


@image_comparison(['axis_artist_ticks.png'], style='default')
def test_ticks():
    fig, ax = plt.subplots()

    ax.xaxis.set_visible(False)
    ax.yaxis.set_visible(False)

    locs_angles = [((i / 10, 0.0), i * 30) for i in range(-1, 12)]

    ticks_in = Ticks(ticksize=10, axis=ax.xaxis)
    ticks_in.set_locs_angles(locs_angles)
    ax.add_artist(ticks_in)

    ticks_out = Ticks(ticksize=10, tick_out=True, color='C3', axis=ax.xaxis)
    ticks_out.set_locs_angles(locs_angles)
    ax.add_artist(ticks_out)


@image_comparison(['axis_artist_labelbase.png'], style='default')
def test_labelbase():
    # Remove this line when this test image is regenerated.
    plt.rcParams['text.kerning_factor'] = 6

    fig, ax = plt.subplots()

    ax.plot([0.5], [0.5], "o")

    label = LabelBase(0.5, 0.5, "Test")
    label._ref_angle = -90
    label._offset_radius = 50
    label.set_rotation(-90)
    label.set(ha="center", va="top")
    ax.add_artist(label)


@image_comparison(['axis_artist_ticklabels.png'], style='default')
def test_ticklabels():
    # Remove this line when this test image is regenerated.
    plt.rcParams['text.kerning_factor'] = 6

    fig, ax = plt.subplots()

    ax.xaxis.set_visible(False)
    ax.yaxis.set_visible(False)

    ax.plot([0.2, 0.4], [0.5, 0.5], "o")

    ticks = Ticks(ticksize=10, axis=ax.xaxis)
    ax.add_artist(ticks)
    locs_angles_labels = [((0.2, 0.5), -90, "0.2"),
                          ((0.4, 0.5), -120, "0.4")]
    tick_locs_angles = [(xy, a + 180) for xy, a, l in locs_angles_labels]
    ticks.set_locs_angles(tick_locs_angles)

    ticklabels = TickLabels(axis_direction="left")
    ticklabels._locs_angles_labels = locs_angles_labels
    ticklabels.set_pad(10)
    ax.add_artist(ticklabels)

    ax.plot([0.5], [0.5], "s")
    axislabel = AxisLabel(0.5, 0.5, "Test")
    axislabel._offset_radius = 20
    axislabel._ref_angle = 0
    axislabel.set_axis_direction("bottom")
    ax.add_artist(axislabel)

    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)


@image_comparison(['axis_artist.png'], style='default')
def test_axis_artist():
    # Remove this line when this test image is regenerated.
    plt.rcParams['text.kerning_factor'] = 6

    fig, ax = plt.subplots()

    ax.xaxis.set_visible(False)
    ax.yaxis.set_visible(False)

    for loc in ('left', 'right', 'bottom'):
        helper = AxisArtistHelperRectlinear.Fixed(ax, loc=loc)
        axisline = AxisArtist(ax, helper, offset=None, axis_direction=loc)
        ax.add_artist(axisline)

    # Settings for bottom AxisArtist.
    axisline.set_label("TTT")
    axisline.major_ticks.set_tick_out(False)
    axisline.label.set_pad(5)

    ax.set_ylabel("Test")
</file>

<file path="test_axislines.py">
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.testing.decorators import image_comparison
from matplotlib.transforms import IdentityTransform

from mpl_toolkits.axisartist.axislines import AxesZero, SubplotZero, Subplot
from mpl_toolkits.axisartist import Axes, SubplotHost


@image_comparison(['SubplotZero.png'], style='default')
def test_SubplotZero():
    # Remove this line when this test image is regenerated.
    plt.rcParams['text.kerning_factor'] = 6

    fig = plt.figure()

    ax = SubplotZero(fig, 1, 1, 1)
    fig.add_subplot(ax)

    ax.axis["xzero"].set_visible(True)
    ax.axis["xzero"].label.set_text("Axis Zero")

    for n in ["top", "right"]:
        ax.axis[n].set_visible(False)

    xx = np.arange(0, 2 * np.pi, 0.01)
    ax.plot(xx, np.sin(xx))
    ax.set_ylabel("Test")


@image_comparison(['Subplot.png'], style='default')
def test_Subplot():
    # Remove this line when this test image is regenerated.
    plt.rcParams['text.kerning_factor'] = 6

    fig = plt.figure()

    ax = Subplot(fig, 1, 1, 1)
    fig.add_subplot(ax)

    xx = np.arange(0, 2 * np.pi, 0.01)
    ax.plot(xx, np.sin(xx))
    ax.set_ylabel("Test")

    ax.axis["top"].major_ticks.set_tick_out(True)
    ax.axis["bottom"].major_ticks.set_tick_out(True)

    ax.axis["bottom"].set_label("Tk0")


def test_Axes():
    fig = plt.figure()
    ax = Axes(fig, [0.15, 0.1, 0.65, 0.8])
    fig.add_axes(ax)
    ax.plot([1, 2, 3], [0, 1, 2])
    ax.set_xscale('log')
    fig.canvas.draw()


@image_comparison(['ParasiteAxesAuxTrans_meshplot.png'],
                  remove_text=True, style='default', tol=0.075)
def test_ParasiteAxesAuxTrans():
    data = np.ones((6, 6))
    data[2, 2] = 2
    data[0, :] = 0
    data[-2, :] = 0
    data[:, 0] = 0
    data[:, -2] = 0
    x = np.arange(6)
    y = np.arange(6)
    xx, yy = np.meshgrid(x, y)

    funcnames = ['pcolor', 'pcolormesh', 'contourf']

    fig = plt.figure()
    for i, name in enumerate(funcnames):

        ax1 = SubplotHost(fig, 1, 3, i+1)
        fig.add_subplot(ax1)

        ax2 = ax1.get_aux_axes(IdentityTransform(), viewlim_mode=None)
        if name.startswith('pcolor'):
            getattr(ax2, name)(xx, yy, data[:-1, :-1])
        else:
            getattr(ax2, name)(xx, yy, data)
        ax1.set_xlim((0, 5))
        ax1.set_ylim((0, 5))

    ax2.contour(xx, yy, data, colors='k')


@image_comparison(['axisline_style.png'], remove_text=True, style='mpl20')
def test_axisline_style():
    fig = plt.figure(figsize=(2, 2))
    ax = fig.add_subplot(axes_class=AxesZero)
    ax.axis["xzero"].set_axisline_style("-|>")
    ax.axis["xzero"].set_visible(True)
    ax.axis["yzero"].set_axisline_style("->")
    ax.axis["yzero"].set_visible(True)

    for direction in ("left", "right", "bottom", "top"):
        ax.axis[direction].set_visible(False)


@image_comparison(['axisline_style_size_color.png'], remove_text=True,
                  style='mpl20')
def test_axisline_style_size_color():
    fig = plt.figure(figsize=(2, 2))
    ax = fig.add_subplot(axes_class=AxesZero)
    ax.axis["xzero"].set_axisline_style("-|>", size=2.0, facecolor='r')
    ax.axis["xzero"].set_visible(True)
    ax.axis["yzero"].set_axisline_style("->, size=1.5")
    ax.axis["yzero"].set_visible(True)

    for direction in ("left", "right", "bottom", "top"):
        ax.axis[direction].set_visible(False)


@image_comparison(['axisline_style_tight.png'], remove_text=True,
                  style='mpl20')
def test_axisline_style_tight():
    fig = plt.figure(figsize=(2, 2), layout='tight')
    ax = fig.add_subplot(axes_class=AxesZero)
    ax.axis["xzero"].set_axisline_style("-|>", size=5, facecolor='g')
    ax.axis["xzero"].set_visible(True)
    ax.axis["yzero"].set_axisline_style("->, size=8")
    ax.axis["yzero"].set_visible(True)

    for direction in ("left", "right", "bottom", "top"):
        ax.axis[direction].set_visible(False)


@image_comparison(['subplotzero_ylabel.png'], style='mpl20')
def test_subplotzero_ylabel():
    fig = plt.figure()
    ax = fig.add_subplot(111, axes_class=SubplotZero)

    ax.set(xlim=(-3, 7), ylim=(-3, 7), xlabel="x", ylabel="y")

    zero_axis = ax.axis["xzero", "yzero"]
    zero_axis.set_visible(True)  # they are hidden by default

    ax.axis["left", "right", "bottom", "top"].set_visible(False)

    zero_axis.set_axisline_style("->")
</file>

<file path="test_floating_axes.py">
import numpy as np

import matplotlib.pyplot as plt
import matplotlib.projections as mprojections
import matplotlib.transforms as mtransforms
from matplotlib.testing.decorators import image_comparison
from mpl_toolkits.axisartist.axislines import Subplot
from mpl_toolkits.axisartist.floating_axes import (
    FloatingAxes, GridHelperCurveLinear)
from mpl_toolkits.axisartist.grid_finder import FixedLocator
from mpl_toolkits.axisartist import angle_helper


def test_subplot():
    fig = plt.figure(figsize=(5, 5))
    ax = Subplot(fig, 111)
    fig.add_subplot(ax)


# Rather high tolerance to allow ongoing work with floating axes internals;
# remove when image is regenerated.
@image_comparison(['curvelinear3.png'], style='default', tol=5)
def test_curvelinear3():
    fig = plt.figure(figsize=(5, 5))

    tr = (mtransforms.Affine2D().scale(np.pi / 180, 1) +
          mprojections.PolarAxes.PolarTransform(apply_theta_transforms=False))
    grid_helper = GridHelperCurveLinear(
        tr,
        extremes=(0, 360, 10, 3),
        grid_locator1=angle_helper.LocatorDMS(15),
        grid_locator2=FixedLocator([2, 4, 6, 8, 10]),
        tick_formatter1=angle_helper.FormatterDMS(),
        tick_formatter2=None)
    ax1 = fig.add_subplot(axes_class=FloatingAxes, grid_helper=grid_helper)

    r_scale = 10
    tr2 = mtransforms.Affine2D().scale(1, 1 / r_scale) + tr
    grid_helper2 = GridHelperCurveLinear(
        tr2,
        extremes=(0, 360, 10 * r_scale, 3 * r_scale),
        grid_locator2=FixedLocator([30, 60, 90]))

    ax1.axis["right"] = axis = grid_helper2.new_fixed_axis("right", axes=ax1)

    ax1.axis["left"].label.set_text("Test 1")
    ax1.axis["right"].label.set_text("Test 2")
    ax1.axis["left", "right"].set_visible(False)

    axis = grid_helper.new_floating_axis(1, 7, axes=ax1,
                                         axis_direction="bottom")
    ax1.axis["z"] = axis
    axis.toggle(all=True, label=True)
    axis.label.set_text("z = ?")
    axis.label.set_visible(True)
    axis.line.set_color("0.5")

    ax2 = ax1.get_aux_axes(tr)

    xx, yy = [67, 90, 75, 30], [2, 5, 8, 4]
    ax2.scatter(xx, yy)
    l, = ax2.plot(xx, yy, "k-")
    l.set_clip_path(ax1.patch)


# Rather high tolerance to allow ongoing work with floating axes internals;
# remove when image is regenerated.
@image_comparison(['curvelinear4.png'], style='default', tol=0.9)
def test_curvelinear4():
    # Remove this line when this test image is regenerated.
    plt.rcParams['text.kerning_factor'] = 6

    fig = plt.figure(figsize=(5, 5))

    tr = (mtransforms.Affine2D().scale(np.pi / 180, 1) +
          mprojections.PolarAxes.PolarTransform(apply_theta_transforms=False))
    grid_helper = GridHelperCurveLinear(
        tr,
        extremes=(120, 30, 10, 0),
        grid_locator1=angle_helper.LocatorDMS(5),
        grid_locator2=FixedLocator([2, 4, 6, 8, 10]),
        tick_formatter1=angle_helper.FormatterDMS(),
        tick_formatter2=None)
    ax1 = fig.add_subplot(axes_class=FloatingAxes, grid_helper=grid_helper)
    ax1.clear()  # Check that clear() also restores the correct limits on ax1.

    ax1.axis["left"].label.set_text("Test 1")
    ax1.axis["right"].label.set_text("Test 2")
    ax1.axis["top"].set_visible(False)

    axis = grid_helper.new_floating_axis(1, 70, axes=ax1,
                                         axis_direction="bottom")
    ax1.axis["z"] = axis
    axis.toggle(all=True, label=True)
    axis.label.set_axis_direction("top")
    axis.label.set_text("z = ?")
    axis.label.set_visible(True)
    axis.line.set_color("0.5")

    ax2 = ax1.get_aux_axes(tr)

    xx, yy = [67, 90, 75, 30], [2, 5, 8, 4]
    ax2.scatter(xx, yy)
    l, = ax2.plot(xx, yy, "k-")
    l.set_clip_path(ax1.patch)


def test_axis_direction():
    # Check that axis direction is propagated on a floating axis
    fig = plt.figure()
    ax = Subplot(fig, 111)
    fig.add_subplot(ax)
    ax.axis['y'] = ax.new_floating_axis(nth_coord=1, value=0,
                                        axis_direction='left')
    assert ax.axis['y']._axis_direction == 'left'
</file>

<file path="test_grid_finder.py">
import numpy as np
import pytest

from matplotlib.transforms import Bbox
from mpl_toolkits.axisartist.grid_finder import (
    _find_line_box_crossings, FormatterPrettyPrint, MaxNLocator)


def test_find_line_box_crossings():
    x = np.array([-3, -2, -1, 0., 1, 2, 3, 2, 1, 0, -1, -2, -3, 5])
    y = np.arange(len(x))
    bbox = Bbox.from_extents(-2, 3, 2, 12.5)
    left, right, bottom, top = _find_line_box_crossings(
        np.column_stack([x, y]), bbox)
    ((lx0, ly0), la0), ((lx1, ly1), la1), = left
    ((rx0, ry0), ra0), ((rx1, ry1), ra1), = right
    ((bx0, by0), ba0), = bottom
    ((tx0, ty0), ta0), = top
    assert (lx0, ly0, la0) == (-2, 11, 135)
    assert (lx1, ly1, la1) == pytest.approx((-2., 12.125, 7.125016))
    assert (rx0, ry0, ra0) == (2, 5, 45)
    assert (rx1, ry1, ra1) == (2, 7, 135)
    assert (bx0, by0, ba0) == (0, 3, 45)
    assert (tx0, ty0, ta0) == pytest.approx((1., 12.5, 7.125016))


def test_pretty_print_format():
    locator = MaxNLocator()
    locs, nloc, factor = locator(0, 100)

    fmt = FormatterPrettyPrint()

    assert fmt("left", None, locs) == \
        [r'$\mathdefault{%d}$' % (l, ) for l in locs]
</file>

<file path="test_grid_helper_curvelinear.py">
import numpy as np

import matplotlib.pyplot as plt
from matplotlib.path import Path
from matplotlib.projections import PolarAxes
from matplotlib.ticker import FuncFormatter
from matplotlib.transforms import Affine2D, Transform
from matplotlib.testing.decorators import image_comparison

from mpl_toolkits.axisartist import SubplotHost
from mpl_toolkits.axes_grid1.parasite_axes import host_axes_class_factory
from mpl_toolkits.axisartist import angle_helper
from mpl_toolkits.axisartist.axislines import Axes
from mpl_toolkits.axisartist.grid_helper_curvelinear import \
    GridHelperCurveLinear


@image_comparison(['custom_transform.png'], style='default', tol=0.2)
def test_custom_transform():
    class MyTransform(Transform):
        input_dims = output_dims = 2

        def __init__(self, resolution):
            """
            Resolution is the number of steps to interpolate between each input
            line segment to approximate its path in transformed space.
            """
            Transform.__init__(self)
            self._resolution = resolution

        def transform(self, ll):
            x, y = ll.T
            return np.column_stack([x, y - x])

        transform_non_affine = transform

        def transform_path(self, path):
            ipath = path.interpolated(self._resolution)
            return Path(self.transform(ipath.vertices), ipath.codes)

        transform_path_non_affine = transform_path

        def inverted(self):
            return MyTransformInv(self._resolution)

    class MyTransformInv(Transform):
        input_dims = output_dims = 2

        def __init__(self, resolution):
            Transform.__init__(self)
            self._resolution = resolution

        def transform(self, ll):
            x, y = ll.T
            return np.column_stack([x, y + x])

        def inverted(self):
            return MyTransform(self._resolution)

    fig = plt.figure()

    SubplotHost = host_axes_class_factory(Axes)

    tr = MyTransform(1)
    grid_helper = GridHelperCurveLinear(tr)
    ax1 = SubplotHost(fig, 1, 1, 1, grid_helper=grid_helper)
    fig.add_subplot(ax1)

    ax2 = ax1.get_aux_axes(tr, viewlim_mode="equal")
    ax2.plot([3, 6], [5.0, 10.])

    ax1.set_aspect(1.)
    ax1.set_xlim(0, 10)
    ax1.set_ylim(0, 10)

    ax1.grid(True)


@image_comparison(['polar_box.png'], style='default', tol=0.04)
def test_polar_box():
    fig = plt.figure(figsize=(5, 5))

    # PolarAxes.PolarTransform takes radian. However, we want our coordinate
    # system in degree
    tr = (Affine2D().scale(np.pi / 180., 1.) +
          PolarAxes.PolarTransform(apply_theta_transforms=False))

    # polar projection, which involves cycle, and also has limits in
    # its coordinates, needs a special method to find the extremes
    # (min, max of the coordinate within the view).
    extreme_finder = angle_helper.ExtremeFinderCycle(20, 20,
                                                     lon_cycle=360,
                                                     lat_cycle=None,
                                                     lon_minmax=None,
                                                     lat_minmax=(0, np.inf))

    grid_helper = GridHelperCurveLinear(
        tr,
        extreme_finder=extreme_finder,
        grid_locator1=angle_helper.LocatorDMS(12),
        tick_formatter1=angle_helper.FormatterDMS(),
        tick_formatter2=FuncFormatter(lambda x, p: "eight" if x == 8 else f"{int(x)}"),
    )

    ax1 = SubplotHost(fig, 1, 1, 1, grid_helper=grid_helper)

    ax1.axis["right"].major_ticklabels.set_visible(True)
    ax1.axis["top"].major_ticklabels.set_visible(True)

    # let right axis shows ticklabels for 1st coordinate (angle)
    ax1.axis["right"].get_helper().nth_coord_ticks = 0
    # let bottom axis shows ticklabels for 2nd coordinate (radius)
    ax1.axis["bottom"].get_helper().nth_coord_ticks = 1

    fig.add_subplot(ax1)

    ax1.axis["lat"] = axis = grid_helper.new_floating_axis(0, 45, axes=ax1)
    axis.label.set_text("Test")
    axis.label.set_visible(True)
    axis.get_helper().set_extremes(2, 12)

    ax1.axis["lon"] = axis = grid_helper.new_floating_axis(1, 6, axes=ax1)
    axis.label.set_text("Test 2")
    axis.get_helper().set_extremes(-180, 90)

    # A parasite axes with given transform
    ax2 = ax1.get_aux_axes(tr, viewlim_mode="equal")
    assert ax2.transData == tr + ax1.transData
    # Anything you draw in ax2 will match the ticks and grids of ax1.
    ax2.plot(np.linspace(0, 30, 50), np.linspace(10, 10, 50))

    ax1.set_aspect(1.)
    ax1.set_xlim(-5, 12)
    ax1.set_ylim(-5, 10)

    ax1.grid(True)


# Remove tol & kerning_factor when this test image is regenerated.
@image_comparison(['axis_direction.png'], style='default', tol=0.13)
def test_axis_direction():
    plt.rcParams['text.kerning_factor'] = 6

    fig = plt.figure(figsize=(5, 5))

    # PolarAxes.PolarTransform takes radian. However, we want our coordinate
    # system in degree
    tr = (Affine2D().scale(np.pi / 180., 1.) +
          PolarAxes.PolarTransform(apply_theta_transforms=False))

    # polar projection, which involves cycle, and also has limits in
    # its coordinates, needs a special method to find the extremes
    # (min, max of the coordinate within the view).

    # 20, 20 : number of sampling points along x, y direction
    extreme_finder = angle_helper.ExtremeFinderCycle(20, 20,
                                                     lon_cycle=360,
                                                     lat_cycle=None,
                                                     lon_minmax=None,
                                                     lat_minmax=(0, np.inf),
                                                     )

    grid_locator1 = angle_helper.LocatorDMS(12)
    tick_formatter1 = angle_helper.FormatterDMS()

    grid_helper = GridHelperCurveLinear(tr,
                                        extreme_finder=extreme_finder,
                                        grid_locator1=grid_locator1,
                                        tick_formatter1=tick_formatter1)

    ax1 = SubplotHost(fig, 1, 1, 1, grid_helper=grid_helper)

    for axis in ax1.axis.values():
        axis.set_visible(False)

    fig.add_subplot(ax1)

    ax1.axis["lat1"] = axis = grid_helper.new_floating_axis(
        0, 130,
        axes=ax1, axis_direction="left")
    axis.label.set_text("Test")
    axis.label.set_visible(True)
    axis.get_helper().set_extremes(0.001, 10)

    ax1.axis["lat2"] = axis = grid_helper.new_floating_axis(
        0, 50,
        axes=ax1, axis_direction="right")
    axis.label.set_text("Test")
    axis.label.set_visible(True)
    axis.get_helper().set_extremes(0.001, 10)

    ax1.axis["lon"] = axis = grid_helper.new_floating_axis(
        1, 10,
        axes=ax1, axis_direction="bottom")
    axis.label.set_text("Test 2")
    axis.get_helper().set_extremes(50, 130)
    axis.major_ticklabels.set_axis_direction("top")
    axis.label.set_axis_direction("top")

    grid_helper.grid_finder.grid_locator1.set_params(nbins=5)
    grid_helper.grid_finder.grid_locator2.set_params(nbins=5)

    ax1.set_aspect(1.)
    ax1.set_xlim(-8, 8)
    ax1.set_ylim(-4, 12)

    ax1.grid(True)
</file>

</files>
