This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
cfl_computation.m
golf_ball_trajectory.m
golf_scramble.m
golf_surface.m
how_do_i_dissertate_plot.m
running_hills.m
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="cfl_computation.m">
%
%
% Playground script to check CFL number computation method. - 8/10/2015.

   % Add to path.
   addpath(genpath(cd));

   % Load the Dongsha case.
   data = smpm_read_initfile( [ pwd '/examples/dongsha_init.h5'] );

   % Unpack.
   x = data.grid.x;
   z = data.grid.z;
   ux = data.ic.ux;
   uz = data.ic.uz;
   n = data.grid.n;
   mx = data.grid.mx;
   mz = data.grid.mz;


   % Build the SMPM differentiation matrices.

      % Compute the GLL gridpoints.
      [eta, w, junk] = lglnodes( n - 1 );
      eta            = flipud( eta )';

      % Compute the spectral differentiation matrix of order 1.
      D1 = zeros( n, n );
      for ii = 1:n
          D1(:, ii) = make_lagrange( eta, eta, ii, 1 );
      end
      eta = eta';

   %  Build the derivative matrices (sparsely) in eta and xi.
   Dxi  = kron( speye( n * mx * mz ), D1 );
   Deta = kron( speye( mx ), kron( D1, speye( n * mz ) ) );

   % Compute some metric terms we'll need.
   x_eta = reshape( Deta * x(:), n * mz, n * mx );
   z_eta = reshape( Deta * z(:), n * mz, n * mx );
   x_xi  = reshape( Dxi * x(:), n * mz, n * mx );
   z_xi  = reshape( Dxi * z(:), n * mz, n * mx );

   % Build the delta-eta term.
   delta_xi = 0 * eta;
   delta_xi(1) = eta(2) - eta(1);
   for ii = 2:n-1
      delta_xi(ii) = eta(ii+1) - eta(ii-1);
   end
   delta_xi(end) = eta(end) - eta(end-1);

   % Expand onto the whole grid.
   DXI  = reshape( kron( ones( n * mx * mz, 1 ), delta_xi ), n * mz, n * mx );
   DETA = reshape( kron( ones( mx, 1 ), kron( delta_xi, ones( n * mz, 1 ) ) ), n * mz, n * mx );

   % Compute the local grid deformations.
   DX = x_eta .* DETA + x_xi .* DXI;
   DZ = z_eta .* DETA + z_xi .* DXI;

   % Compute the local maximum time-step.
   dtx = DX ./ ux;
   dtz = DZ ./ uz;

   % Compute the maximum time-step.
   dt_max   = min(min(abs(dtx(:))), min(abs(dtz(:))));
   u = hypot( ux, uz );
   dt_max_2 = min( min( abs( DX(:) ) ), min( abs( DZ(:) ) ) ) / max( abs( u(:) ) );

   % Make some graphics.

      % Figure 0. Graphic of the initial condition.
      figure;
      contourf( x/1000, z, u );
      ax = gca;
      smpm_visualize_mesh( n, mx, mz, x/1000, z, gcf );
      cb = colorbar;
      xlabel('kilometers');
      ylabel('meters');
      set( gcf, 'pos', [28         386        1135         246] );
      axes( cb );
      ylabel( 'velocity in meters/second' );
      fixfig_pres;
      print_graphics( gcf, 'cfl_velocity', 0, 1, 0, 0 );
      set( ax, 'xlim', [0, 10.0] );
      fixfig_pres;
      print_graphics( gcf, 'cfl_velocity_zoom', 0, 1, 0, 0 );

      % Figure 1. Maximum time-step graphic.
      figure;
      contourf( x/1000, z, min( abs(dtx), abs(dtz) ), linspace( 0.0, 500, 25 ) );
      smpm_visualize_mesh( n, mx, mz, x/1000, z, gcf );
      ax = gca;
      cb = colorbar;
      set( gcf, 'pos', [28         386        1135         246] );
      xlabel('kilometers');
      ylabel('meters');
      axes( cb );
      ylabel( 'time-step in seconds' );
      fixfig_pres;
      print_graphics( gcf, 'cfl_timestep', 0, 1, 0, 0 );
      set( ax, 'xlim', [0 10] );
      fixfig_pres;
      print_graphics( gcf, 'cfl_timestep_zoom', 0, 1, 0, 0 );

      % Figure 2. Mesh.
      figure;
      smpm_visualize_mesh( n, mx, mz, x/1000, z );
      set( gcf, 'pos', [28         386        1135         246] );
      xlabel('kilometers');
      ylabel('meters');
      fixfig_pres;
      set(gca, 'ylim', [min(z(:)), 0], 'xlim', [0, max(x(:)/1000)] );
      print_graphics( gcf, 'cfl_mesh', 0, 1, 0, 0 );

      % Figure 3. Local deformations dx and dz.
      figure;
      contourf( x/1000, z, DZ );
      smpm_visualize_mesh( n, mx, mz, x/1000, z, gcf );
      set( gcf, 'pos', [28         386        1135         246] );
      xlabel('kilometers');
      ylabel('meters');
      fixfig_pres;
      print_graphics( gcf, 'cfl_dz', 0, 1, 0, 0 );

      figure;
      contourf( x/1000, z, DX );
      smpm_visualize_mesh( n, mx, mz, x/1000, z, gcf );
      set( gcf, 'pos', [28         386        1135         246] );
      xlabel('kilometers');
      ylabel('meters');
      fixfig_pres;
      print_graphics( gcf, 'cfl_dx', 0, 1, 0, 0 );
</file>

<file path="golf_ball_trajectory.m">
%
% Calculate the distance traveled by a golf ball bouncing along concrete.
%
% 09 Sept 2015
% Sumedh Joshi

% Physics: http://farside.ph.utexas.edu/teaching/336k/Newtonhtml/node29.html

   % Set some constants.
   g   = 9.81;         % Acceleration due to gravity.
   m   = 45.93 / 1000; % Mass of a golf ball in kg.
   r   = 0.02135;      % Radius of a golf ball in m.
   vt  = 31.36;        % Terminal velocity of a golf ball in m/s.
   cor = 0.85;         % Coefficient of resititution; unitless.
   cd  = m * g / vt;   % Drag coefficient.

   % Set some initial conditions in miles per hour, degrees from horizontal, and RPM.
   launch_speed    = 0;
   launch_angle    = 0;
   launch_backspin = 0;

   % Convert initial velocity to meters per second.
   v0 = launch_speed / 2.236;

   % Calculate the launch angle in radians.
   theta = launch_angle * pi / 180;

   % Calculate the backspin in radians / second.
   theta_dot = launch_backspin * ( 2 * pi ) / 60;

   % Set the terminal rotational velocity.
   theta_dot_t = vt / r;

   % Moment of rotational inertia of a golf ball.
   I = ( 2 / 5 ) * m * r^2;

   % Set the density of air in kg/m^3.
   rho = 1.02;

   % Time-stepping parameters.
   dt   = 1e-2;
   vmin = r/2;
   t  = [0];
   x  = [1];
   z  = [1.0];
   vx = [ v0 * cos( theta ) ];
   vz = [ v0 * sin( theta ) ];

   % Step forward in time until the velocity of the ball is small.
   xoffset = 0.0;
   bounce_count = 0;
   while hypot( vx(end), vz(end) ) > vmin || ( ( hypot( vx(end), vz(end) ) < vmin ) && z(end) > r )

      % Step forward in time.
      t = [ t; t(end) + dt ];

      % Calculate the Magnus force from the rotation.
      G   = 2 * pi * r^2 * theta_dot(end);
      Fm  = rho * G;

      % Integrate the velocities.
      iivx = vx(end) - dt * g * vx(end) / vt;
      iivz = vz(end) - dt * g * ( 1 + vz(end) / vt ) + dt * Fm * vx(end) / m;
      iix  = x(end) + dt * iivx;
      iiz  = z(end) + dt * iivz;

      % Model rotational decay.
      iitheta_dot = theta_dot(end) - dt * theta_dot(end) / theta_dot_t / I;
      theta_dot = [ theta_dot; iitheta_dot ];

      % Check for a bounce.
      if iiz < 0

         % Reset the launch angles and velocities.
         iiz = 0;
         iivz(end) = cor * -1.0 * iivz(end);
         theta = atan( iivz(end) / iivx(end) );

         % Set the backspin to zero.
         theta_dot(end) = -theta_dot(end);

         % Count bounces if it bounces significantly.
         bounce_count = bounce_count + 1;

         % Switch to a roll if the ball is done bouncing significantly.

      end

      % Store.
      x  = [x; iix];
      z  = [z; iiz];
      vx = [vx; iivx];
      vz = [vz; iivz];

   end

   % Convert to yards.
   m2y = 0.914;
   xy = x * m2y;
   zy = z * m2y;
</file>

<file path="golf_scramble.m">
%
% How many of me does it take to shoot par in a scramble?
% Septmber 7th, 2015.

   % Set some parameters about me.
   max_p = 250.0;
   std_p = 0.3713;
   std_p = 0.2723;

   % Number of trials.
   Ntrials = 50;

   % Cup size.
   cup_size = 0.118;

   % Set up a round of golf.
   holes = [ ones( 4, 1 ) * 550; ones( 4, 1 ) * 150; ones( 10, 1 ) * 350 ];

   % Number of golfers in the "scramble".
   scramble = 2;

   % Initialize the score to 0.
   score = 0 * holes;

   % Create a meshgrid of data points to study.
   skill          = linspace( 0.01, 0.5, 50 );
   drive_distance = linspace( 100.0, 350.0, 50 );
   players        = [ 1 2 3 4 ];

   % Setup an array to store the score.
   score_surface = zeros( length(drive_distance), length(skill), length(players) );

   % Loop over each drive distance.
   for iidrive_distance = 1:length(drive_distance)

      % Loop over skill.
      for iiskill = 1:length(skill)

         % Loop over players.
         for iiplayers = 1:length(players)

            p( iidrive_distance * iiskill * iiplayers, length(drive_distance) * length(skill) * length(players) );

            % Set the current player parameters.
            std_p = skill(iiskill);
            max_p = drive_distance( iidrive_distance );
            scramble = players( iiplayers );

            % Loop over trials.
            for iitrial = 1:Ntrials

               % Play the scramble.
               for ii = 1:length(holes)

                  % Set the current distance.
                  iidistance = holes(ii);
                  strokes    = 0;

                  % Play this shot.
                  while abs(iidistance) > cup_size
                     if iidistance > max_p
                        iidistance_next = iidistance -      max_p * ( 1.0 + std_p * randn(scramble, 1) );
                     else
                        iidistance_next = iidistance - iidistance * ( 1.0 + std_p * randn( scramble, 1 ) );
                     end

                     % Take the best shot and add a stroke.
                     [junk ndx] = min( abs( iidistance_next ) );
                     iidistance = iidistance_next( ndx );
                     strokes    = strokes + 1;
                  end

                  % Keep track of the score.
                  score(ii) = strokes;

               end

               score_surface( iidrive_distance, iiskill, iiplayers ) = score_surface( iidrive_distance, iiskill, iiplayers ) + sum( score ) / Ntrials;

            end
          end
      end
   end

   % Make panel plot.
   figure;
   ax(1) = subplot(2,2,1);
   contourf( skill, drive_distance, score_surface(:, :, 1 ) );
   hold on;
   [junk h ] = contour( skill, drive_distance, score_surface(:,:,1), [72.0 72.0] );
   set( h, 'linecolor', [1 0 1] , 'linewidth', 2.0 );
   ylabel( 'Mean Drive Distance' );
   title( 'One Player Scramble' );
   set( gca, 'xtick', [0.1000    0.2000    0.3000    0.4000    0.5000] );
   colorbar;

   ax(2) = subplot(2,2,2);
   contourf( skill, drive_distance, score_surface(:, :, 2 ) );
   hold on;
   [junk h ] = contour( skill, drive_distance, score_surface(:,:,2), [72.0 72.0] );
   set( h, 'linecolor', [1 0 1] , 'linewidth', 2.0 );
   title( 'Two Player Scramble' );
   set( gca, 'xtick', [0.1000    0.2000    0.3000    0.4000    0.5000] );
   colorbar;

   ax(3) = subplot(2,2,3);
   contourf( skill, drive_distance, score_surface(:, :, 3 ) );
   hold on;
   [junk h ] = contour( skill, drive_distance, score_surface(:,:,3), [72.0 72.0] );
   set( h, 'linecolor', [1 0 1], 'linewidth', 2.0 );
   title( 'Three Player Scramble' );
   ylabel( 'Mean Drive Distance' );
   xlabel( '\alpha' );
   set( gca, 'xtick', [0.1000    0.2000    0.3000    0.4000    0.5000] );
   colorbar;

   ax(4) = subplot(2,2,4);
   contourf( skill, drive_distance, score_surface(:, :, 4 ) );
   hold on;
   [junk h ] = contour( skill, drive_distance, score_surface(:,:,4), [72.0 72.0] );
   set( h, 'linecolor', [1 0 1], 'linewidth', 2.0 );
   title( 'Four Player Scramble' );
   xlabel( '\alpha' );
   set( gca, 'xtick', [0.1000    0.2000    0.3000    0.4000    0.5000] );
   colorbar;

   c = caxis;
   %set( ax, 'clim', c );
   set( gcf,'pos', [290   139   786   590] );
</file>

<file path="golf_surface.m">
% Playing a hole of golf as a sequence of Gaussian random variables.
%
%  Monday, September 9th, 2015.

   % Set some player parameters.  All distances in yards.
   max_p = 250.0;  % Mean maximum distance.
   std_p = 0.2;   % Standard deviation.

   % Set some hole parameters.
   d = 450;

   % Set the cup width.
   c = 0.118;

   % Set up a round of golf.
   holes = [ ones( 4, 1 ) * 550; ones( 4, 1 ) * 150; ones( 10, 1 ) * 350 ];

   % Play a motherfucking round of golf.
   for ii = 1:length(holes)
      round{ii} = simulate_hole( holes(ii), max_p, std_p );
      score(ii) = length(round{ii});
   end

   % Over a bunch of different values of the standard deviation play a few rounds of golf.
   skill          = linspace( 0.01, 0.5, 100 );
   drive_distance = linspace( 100.0, 350.0, 100 );
   score_mean = 0 * skill;
   score_std  = 0 * skill;
   trials     = 100;
   count      = 1;
   for iimax = 1:length(drive_distance)
      for iistd = 1:length(skill)

         % Simulate a bunch of rounds of golf.
         score = zeros( trials, 1 );
         for iitrial = 1:trials

            % Simulate a round of golf.
            iiscore = 0;
            for ii = 1:length(holes)
               iihole = simulate_hole( holes(ii), drive_distance(iimax), skill(iistd) );
               iiscore = iiscore + length(iihole) - 1; % -1 because the tee shot distance isn't a stroke.
            end
            score( iitrial ) = iiscore;
         end

         % Store this golfer's information.
         score_mean(iimax,iistd) = mean( score );
         score_std(iimax,iistd)  = std( score );

         % Display some information.
         fprintf( [ 'Trial ' num2str( count ) ' out of ' num2str( length(skill)*length(drive_distance) ) ' complete. \n' ] );
         count = count + 1;

      end
   end

   % Generate a plot.
   plot(skill,score_mean);
   hold on;
   plot(skill,score_mean + score_std,'k--');
   plot(skill,score_mean - score_std,'k--');
   xlabel('\alpha');
   ylabel('Score');
</file>

<file path="how_do_i_dissertate_plot.m">
% Loop over the dates loating data.
fid = fopen( 'dates.txt' );
for ii = 1:43
   iiline = strtrim( fgetl(fid) );
   this_date_str = [ iiline(9:10) '-' iiline(5:7) '-2016 ' iiline(12:end) ];
   date_num(ii) = datenum(this_date_str);
end
fclose( fid );
date_num = flipud(date_num');
date_num = date_num - date_num(1);

% Load the data representing the length of my dissertation.
words = importdata( 'word_length.txt' );

% Make a plot.
figure;
plot( date_num, words, 'b--.' );
xlabel( 'Number of Days Since I Created dissertation.tex' );
ylabel( 'Number of Words in dissertation.tex' );
fixfig_pres;
</file>

<file path="running_hills.m">
%
% How hard is running hills?  Computation and plots for the blog post.
% July 26th, 2015.

% Add my local MATLAB tools to my path.
addpath(genpath('/Users/joshi/Dropbox/matlab'));

% Figure 0: Make a plot of the counter/clockwise loop.
x = linspace( 0, 2.5, 100 );
s = x;
m = 30; % Peak height of the hill.
s( x <= 2.0 ) =  m / 2;
s( x >  2.0 ) = -m / 0.5;
z = cumtrapz( x, s );
plot( x, z );
hold on;
plot( x, fliplr( z ), 'r' );

   % Make a plot.
   set(gcf,'position',[106         296        1065         390]);
   ylabel( 'Elevation' );
   legend( 'Clockwise', 'Counterclockwise', 'Location', 'NorthOutside' );
   set(gca,'xtick',[0,2.5],'xticklabel',{'Start','Finish'});
   set(gca,'ytick',[]);

   % Add labels for the steep and shallow slopes.
   text( 0.75, 10, 'shallow (m = s)', 'color', 'b' );
   text( 2.15, 25, 'steep (m = -t)', 'color', 'b' );
   text( 0.35, 20, 'steep (m = t )', 'color', 'r' );
   text( 1.5, 17, 'shallow (m = -s)','color', 'r' );

   fixfig_pres;

   % Print the picture and move it to the ../images directory.
   print_graphics( gcf, 'running_hills', 0, 1, 0, 0 );
   !mv running_hills.png ../../images
</file>

</files>
