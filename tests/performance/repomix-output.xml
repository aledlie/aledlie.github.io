This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
core-web-vitals.test.js
lighthouse.js
README_ENHANCED.md
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="core-web-vitals.test.js">
/**
 * Core Web Vitals Tests
 * Tests performance metrics that Google uses for ranking
 */

describe('Core Web Vitals', () => {
  describe('Largest Contentful Paint (LCP)', () => {
    test('should measure LCP timing', () => {
      // Mock PerformanceObserver for LCP
      const mockLCPEntries = [{
        entryType: 'largest-contentful-paint',
        startTime: 1200, // 1.2 seconds
        element: document.createElement('img')
      }];

      const measureLCP = () => {
        return new Promise(resolve => {
          // Simulate LCP measurement
          setTimeout(() => resolve(mockLCPEntries[0].startTime), 100);
        });
      };

      return measureLCP().then(lcp => {
        expect(lcp).toBeLessThan(2500); // Good LCP threshold
        expect(typeof lcp).toBe('number');
      });
    });

    test('should identify LCP element', () => {
      document.body.innerHTML = `
        <img src="/images/hero.jpg" alt="Hero image" id="hero">
        <h1>Main heading</h1>
        <p>Some content</p>
      `;

      const potentialLCPElements = document.querySelectorAll('img, h1, h2, p, div');
      expect(potentialLCPElements.length).toBeGreaterThan(0);

      const heroImage = document.querySelector('#hero');
      expect(heroImage).toBeTruthy();
      expect(heroImage.tagName).toBe('IMG');
    });
  });

  describe('First Input Delay (FID)', () => {
    test('should handle user interactions promptly', (done) => {
      const button = document.createElement('button');
      button.textContent = 'Click me';
      document.body.appendChild(button);

      const startTime = performance.now();
      
      button.addEventListener('click', () => {
        const inputDelay = performance.now() - startTime;
        expect(inputDelay).toBeLessThan(100); // Good FID threshold
        done();
      });

      // Simulate immediate click
      setTimeout(() => button.click(), 0);
    });

    test('should not block main thread', () => {
      const performHeavyTask = () => {
        const start = performance.now();
        // Simulate work without blocking
        return new Promise(resolve => {
          setTimeout(() => {
            const duration = performance.now() - start;
            resolve(duration);
          }, 10);
        });
      };

      return performHeavyTask().then(duration => {
        expect(duration).toBeLessThan(50); // Keep main thread responsive
      });
    });
  });

  describe('Cumulative Layout Shift (CLS)', () => {
    test('should not cause unexpected layout shifts', () => {
      // Mock layout shift detection
      const layoutShifts = [];
      
      const mockLayoutShift = (element, oldRect, newRect) => {
        const impact = Math.abs(newRect.top - oldRect.top) / window.innerHeight;
        const distance = Math.abs(newRect.top - oldRect.top) / window.innerHeight;
        const shift = impact * distance;
        
        layoutShifts.push(shift);
        return shift;
      };

      // Simulate a small layout shift
      const shift = mockLayoutShift(
        document.createElement('div'),
        { top: 100, height: 50 },
        { top: 105, height: 50 }
      );

      expect(shift).toBeLessThan(0.1); // Good CLS threshold
      
      const totalCLS = layoutShifts.reduce((sum, shift) => sum + shift, 0);
      expect(totalCLS).toBeLessThan(0.1);
    });

    test('should have proper image sizing to prevent shifts', () => {
      document.body.innerHTML = `
        <img src="/images/test.jpg" width="300" height="200" alt="Test image">
        <img src="/images/test2.jpg" style="width: 300px; height: 200px;" alt="Test image 2">
      `;

      const images = document.querySelectorAll('img');
      
      images.forEach(img => {
        const hasWidthAttr = img.getAttribute('width');
        const hasHeightAttr = img.getAttribute('height');
        const hasStyleDimensions = img.style.width && img.style.height;
        const hasNaturalDimensions = img.width > 0 && img.height > 0;
        
        const hasExplicitDimensions = 
          (hasWidthAttr && hasHeightAttr) ||
          hasStyleDimensions ||
          hasNaturalDimensions;
        
        expect(hasExplicitDimensions).toBeTruthy();
      });
    });

    test('should reserve space for dynamic content', () => {
      // Test that containers have min-height or explicit dimensions
      document.body.innerHTML = `
        <div class="ad-container" style="min-height: 250px;">
          <!-- Ad content loads here -->
        </div>
        <div class="content-placeholder" style="height: 200px;">
          <!-- Content loads here -->
        </div>
      `;

      const containers = document.querySelectorAll('.ad-container, .content-placeholder');
      
      containers.forEach(container => {
        const style = window.getComputedStyle(container);
        const hasReservedSpace = 
          style.minHeight !== 'auto' || 
          style.height !== 'auto';
        
        // In a real test, you'd check computed styles
        // Here we just verify the elements exist
        expect(container).toBeTruthy();
      });
    });
  });

  describe('First Contentful Paint (FCP)', () => {
    test('should render content quickly', () => {
      // Mock FCP measurement
      const mockFCP = 800; // 0.8 seconds

      expect(mockFCP).toBeLessThan(1800); // Good FCP threshold
      expect(mockFCP).toBeGreaterThan(0);
    });

    test('should have critical CSS inlined', () => {
      document.head.innerHTML = `
        <style>
          /* Critical CSS */
          body { font-family: system-ui; }
          .header { background: white; }
        </style>
        <link rel="stylesheet" href="/assets/css/main.css">
      `;

      const inlineStyles = document.querySelector('head style');
      const externalStyles = document.querySelector('link[rel="stylesheet"]');

      expect(inlineStyles).toBeTruthy();
      expect(externalStyles).toBeTruthy();
    });
  });

  describe('Time to Interactive (TTI)', () => {
    test('should become interactive within reasonable time', () => {
      // Mock TTI measurement
      const mockTTI = 2800; // 2.8 seconds

      expect(mockTTI).toBeLessThan(3800); // Good TTI threshold
    });

    test('should load critical JavaScript early', () => {
      document.body.innerHTML = `
        <script>
          // Critical inline JavaScript
          document.documentElement.className = 'js';
        </script>
        <script src="/assets/js/main.js" defer></script>
      `;

      const inlineScript = document.querySelector('body script:not([src])');
      const deferredScript = document.querySelector('script[defer]');

      expect(inlineScript).toBeTruthy();
      expect(deferredScript).toBeTruthy();
      expect(deferredScript.defer).toBe(true);
    });
  });

  describe('Resource Loading Optimization', () => {
    test('should preload critical resources', () => {
      document.head.innerHTML = `
        <link rel="preload" href="/assets/css/main.css" as="style">
        <link rel="preload" href="/assets/fonts/main.woff2" as="font" type="font/woff2" crossorigin>
        <link rel="dns-prefetch" href="https://www.googletagmanager.com">
      `;

      const preloadCSS = document.querySelector('link[rel="preload"][as="style"]');
      const preloadFont = document.querySelector('link[rel="preload"][as="font"]');
      const dnsPrefetch = document.querySelector('link[rel="dns-prefetch"]');

      expect(preloadCSS).toBeTruthy();
      expect(preloadFont).toBeTruthy();
      expect(dnsPrefetch).toBeTruthy();
    });

    test('should use modern image formats', () => {
      document.body.innerHTML = `
        <picture>
          <source srcset="/images/hero.avif" type="image/avif">
          <source srcset="/images/hero.webp" type="image/webp">
          <img src="/images/hero.jpg" alt="Hero image">
        </picture>
      `;

      const picture = document.querySelector('picture');
      const avifSource = document.querySelector('source[type="image/avif"]');
      const webpSource = document.querySelector('source[type="image/webp"]');
      const fallbackImg = document.querySelector('picture img');

      expect(picture).toBeTruthy();
      expect(avifSource).toBeTruthy();
      expect(webpSource).toBeTruthy();
      expect(fallbackImg).toBeTruthy();
    });

    test('should lazy load non-critical images', () => {
      document.body.innerHTML = `
        <img src="/images/hero.jpg" alt="Above fold" loading="eager">
        <img src="/images/content1.jpg" alt="Below fold" loading="lazy">
        <img src="/images/content2.jpg" alt="Below fold" loading="lazy">
      `;

      const eagerImage = document.querySelector('img[loading="eager"]');
      const lazyImages = document.querySelectorAll('img[loading="lazy"]');

      expect(eagerImage).toBeTruthy();
      expect(lazyImages.length).toBeGreaterThan(0);
    });
  });
});
</file>

<file path="lighthouse.js">
/**
 * Lighthouse Performance Testing
 * Uses Lighthouse to test site performance, accessibility, SEO, and best practices
 */

const lighthouse = require('lighthouse');
const chromeLauncher = require('chrome-launcher');
const fs = require('fs');
const path = require('path');

class PerformanceTestSuite {
  constructor(baseUrl = 'http://localhost:4000') {
    this.baseUrl = baseUrl;
    this.chrome = null;
    this.results = [];
  }

  async setup() {
    console.log('Launching Chrome for Lighthouse tests...');
    this.chrome = await chromeLauncher.launch({
      chromeFlags: ['--headless', '--no-sandbox', '--disable-dev-shm-usage']
    });
  }

  async teardown() {
    if (this.chrome) {
      await this.chrome.kill();
    }
  }

  async runLighthouseTest(url, options = {}) {
    const defaultOptions = {
      logLevel: 'info',
      output: 'json',
      port: this.chrome.port,
      onlyCategories: ['performance', 'accessibility', 'best-practices', 'seo'],
    };

    const mergedOptions = { ...defaultOptions, ...options };

    try {
      console.log(`Running Lighthouse test for: ${url}`);
      const runnerResult = await lighthouse(url, mergedOptions);
      
      if (!runnerResult || !runnerResult.lhr) {
        throw new Error('Lighthouse test failed - no results returned');
      }

      return runnerResult.lhr;
    } catch (error) {
      console.error(`Lighthouse test failed for ${url}:`, error);
      return null;
    }
  }

  async testPage(pagePath, pageName) {
    const url = `${this.baseUrl}${pagePath}`;
    const result = await this.runLighthouseTest(url);
    
    if (!result) {
      console.error(`Failed to test ${pageName}`);
      return null;
    }

    const scores = {
      performance: result.categories.performance?.score * 100 || 0,
      accessibility: result.categories.accessibility?.score * 100 || 0,
      bestPractices: result.categories['best-practices']?.score * 100 || 0,
      seo: result.categories.seo?.score * 100 || 0,
    };

    const metrics = {
      firstContentfulPaint: result.audits['first-contentful-paint']?.displayValue || 'N/A',
      largestContentfulPaint: result.audits['largest-contentful-paint']?.displayValue || 'N/A',
      speedIndex: result.audits['speed-index']?.displayValue || 'N/A',
      totalBlockingTime: result.audits['total-blocking-time']?.displayValue || 'N/A',
      cumulativeLayoutShift: result.audits['cumulative-layout-shift']?.displayValue || 'N/A',
    };

    const pageResult = {
      pageName,
      url,
      scores,
      metrics,
      timestamp: new Date().toISOString(),
      passed: this.evaluateScores(scores)
    };

    this.results.push(pageResult);
    this.logPageResult(pageResult);
    
    return pageResult;
  }

  evaluateScores(scores) {
    // Define minimum acceptable scores
    const thresholds = {
      performance: 90,
      accessibility: 95,
      bestPractices: 90,
      seo: 95
    };

    const passed = Object.keys(thresholds).every(category => 
      scores[category] >= thresholds[category]
    );

    return passed;
  }

  logPageResult(result) {
    console.log(`\nðŸ“Š Results for ${result.pageName}:`);
    console.log(`ðŸš€ Performance: ${result.scores.performance.toFixed(1)}/100`);
    console.log(`â™¿ Accessibility: ${result.scores.accessibility.toFixed(1)}/100`);
    console.log(`âœ… Best Practices: ${result.scores.bestPractices.toFixed(1)}/100`);
    console.log(`ðŸ” SEO: ${result.scores.seo.toFixed(1)}/100`);
    console.log(`âš¡ First Contentful Paint: ${result.metrics.firstContentfulPaint}`);
    console.log(`ðŸŽ¨ Largest Contentful Paint: ${result.metrics.largestContentfulPaint}`);
    console.log(`ðŸ“ˆ Speed Index: ${result.metrics.speedIndex}`);
    console.log(`â±ï¸  Total Blocking Time: ${result.metrics.totalBlockingTime}`);
    console.log(`ðŸ“ Cumulative Layout Shift: ${result.metrics.cumulativeLayoutShift}`);
    console.log(`${result.passed ? 'âœ… PASSED' : 'âŒ FAILED'} performance thresholds\n`);
  }

  async runFullSuite() {
    const pagesToTest = [
      { path: '/', name: 'Homepage' },
      { path: '/about/', name: 'About Page' },
      { path: '/posts/', name: 'Posts Page' },
      { path: '/projects/', name: 'Projects Page' }
    ];

    console.log('ðŸš€ Starting comprehensive performance test suite...\n');
    
    await this.setup();

    try {
      for (const page of pagesToTest) {
        await this.testPage(page.path, page.name);
        // Small delay between tests
        await new Promise(resolve => setTimeout(resolve, 1000));
      }

      this.generateSummaryReport();
      this.saveResults();

      const allPassed = this.results.every(result => result.passed);
      
      if (allPassed) {
        console.log('ðŸŽ‰ All performance tests passed!');
        process.exit(0);
      } else {
        console.log('âŒ Some performance tests failed. Check the results above.');
        process.exit(1);
      }

    } catch (error) {
      console.error('Performance test suite failed:', error);
      process.exit(1);
    } finally {
      await this.teardown();
    }
  }

  generateSummaryReport() {
    console.log('\nðŸ“‹ PERFORMANCE TEST SUMMARY');
    console.log('================================');
    
    const totalTests = this.results.length;
    const passedTests = this.results.filter(r => r.passed).length;
    const failedTests = totalTests - passedTests;

    console.log(`Total pages tested: ${totalTests}`);
    console.log(`Passed: ${passedTests}`);
    console.log(`Failed: ${failedTests}`);
    console.log(`Success rate: ${((passedTests / totalTests) * 100).toFixed(1)}%`);

    // Calculate average scores
    const avgScores = this.results.reduce((acc, result) => {
      Object.keys(result.scores).forEach(category => {
        acc[category] = (acc[category] || 0) + result.scores[category];
      });
      return acc;
    }, {});

    Object.keys(avgScores).forEach(category => {
      avgScores[category] = (avgScores[category] / totalTests).toFixed(1);
    });

    console.log('\nðŸ“Š Average Scores:');
    console.log(`Performance: ${avgScores.performance}/100`);
    console.log(`Accessibility: ${avgScores.accessibility}/100`);
    console.log(`Best Practices: ${avgScores.bestPractices}/100`);
    console.log(`SEO: ${avgScores.seo}/100`);

    // Identify failing pages
    const failedPages = this.results.filter(r => !r.passed);
    if (failedPages.length > 0) {
      console.log('\nâŒ Pages that failed performance thresholds:');
      failedPages.forEach(page => {
        console.log(`- ${page.pageName}: ${page.url}`);
      });
    }
  }

  saveResults() {
    const resultsDir = path.join(__dirname, 'results');
    if (!fs.existsSync(resultsDir)) {
      fs.mkdirSync(resultsDir, { recursive: true });
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `lighthouse-results-${timestamp}.json`;
    const filepath = path.join(resultsDir, filename);

    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        totalTests: this.results.length,
        passedTests: this.results.filter(r => r.passed).length,
        failedTests: this.results.filter(r => !r.passed).length
      },
      results: this.results
    };

    fs.writeFileSync(filepath, JSON.stringify(report, null, 2));
    console.log(`\nðŸ“„ Detailed results saved to: ${filepath}`);
  }
}

// Additional performance utilities
class PerformanceUtils {
  static async checkSiteAvailability(url, maxRetries = 5) {
    for (let i = 0; i < maxRetries; i++) {
      try {
        const response = await fetch(url);
        if (response.ok) {
          console.log(`âœ… Site is available at ${url}`);
          return true;
        }
      } catch (error) {
        console.log(`â³ Attempt ${i + 1}/${maxRetries}: Site not available yet, retrying in 5s...`);
        await new Promise(resolve => setTimeout(resolve, 5000));
      }
    }
    throw new Error(`Site not available at ${url} after ${maxRetries} attempts`);
  }

  static async measurePageLoadTime(url) {
    const start = performance.now();
    try {
      await fetch(url);
      const end = performance.now();
      return end - start;
    } catch (error) {
      console.error(`Failed to measure load time for ${url}:`, error);
      return null;
    }
  }
}

// Run the performance test suite
async function main() {
  const baseUrl = process.env.BASE_URL || 'http://localhost:4000';
  
  console.log(`Testing site performance at: ${baseUrl}`);
  
  // Check if site is available before running tests
  try {
    await PerformanceUtils.checkSiteAvailability(baseUrl);
  } catch (error) {
    console.error('Site is not available for testing:', error.message);
    console.log('Make sure to run `npm run serve` in another terminal first.');
    process.exit(1);
  }

  const testSuite = new PerformanceTestSuite(baseUrl);
  await testSuite.runFullSuite();
}

// Export for use in other files
module.exports = { PerformanceTestSuite, PerformanceUtils };

// Run if called directly
if (require.main === module) {
  main().catch(error => {
    console.error('Performance test suite failed:', error);
    process.exit(1);
  });
}
</file>

<file path="README_ENHANCED.md">
# performance

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "performance",
  "description": "Directory containing 2 code files with 2 classes and 4 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "2 class definitions",
    "4 function definitions"
  ]
}
</script>

## Overview

This directory contains 2 code file(s) with extracted schemas.

## Files and Schemas

### `core-web-vitals.test.js` (typescript)

**Functions:**
- `measureLCP()` - Line 15
- `performHeavyTask()` - Line 63
- `mockLayoutShift()` - Line 85

### `lighthouse.js` (typescript)

**Classes:**
- `PerformanceTestSuite` - Line 10
- `PerformanceUtils` - Line 231

**Functions:**
- `async main()` - Line 262

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="README.md">
# performance

## Overview

This directory contains 1 code file(s) with extracted schemas.

## Files and Schemas

### `lighthouse.js` (typescript)

**Classes:**
- `PerformanceTestSuite` - Line 11
- `PerformanceUtils` - Line 232

**Functions:**
- `main()` - Line 263

---
*Generated by Schema Generator*
</file>

</files>
